<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fortrançš„23ç§è®¾è®¡æ¨¡å¼</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> å…³äº</a></li><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">2.</strong> Fortrançš„23ç§è®¾è®¡æ¨¡å¼</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="creational/abstract-factory.html"><strong aria-hidden="true">3.</strong> æŠ½è±¡å·¥å‚æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="creational/builder.html"><strong aria-hidden="true">4.</strong> ç”Ÿæˆå™¨æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="creational/factory.html"><strong aria-hidden="true">5.</strong> å·¥å‚æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="creational/prototype.html"><strong aria-hidden="true">6.</strong> åŸå‹æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="creational/singleton.html"><strong aria-hidden="true">7.</strong> å•ä¾‹æ¨¡å¼</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="structural/adapter.html"><strong aria-hidden="true">8.</strong> é€‚é…å™¨æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="structural/bridge.html"><strong aria-hidden="true">9.</strong> æ¡¥æ¥æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="structural/cache.html"><strong aria-hidden="true">10.</strong> äº«å…ƒæ¨¡å¼</a></li><li class="chapter-item expanded "><a href="structural/composite.html"><strong aria-hidden="true">11.</strong> ç»„åˆæ¨¡å¼</a></li><li class="chapter-item expanded "><a href="structural/facade.html"><strong aria-hidden="true">12.</strong> å¤–è§‚æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="structural/proxy.html"><strong aria-hidden="true">13.</strong> ä»£ç†æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="structural/wrapper.html"><strong aria-hidden="true">14.</strong> è£…é¥°æ¨¡å¼</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="behavioral/chain-of-responsibility.html"><strong aria-hidden="true">15.</strong> è´£ä»»é“¾æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/command.html"><strong aria-hidden="true">16.</strong> å‘½ä»¤æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/iterator.html"><strong aria-hidden="true">17.</strong> è¿­ä»£å™¨æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/observer.html"><strong aria-hidden="true">18.</strong> è§‚å¯Ÿè€…æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/mediator.html"><strong aria-hidden="true">19.</strong> ä¸­ä»‹è€…æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/memento.html"><strong aria-hidden="true">20.</strong> å¤‡å¿˜å½•æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/state.html"><strong aria-hidden="true">21.</strong> çŠ¶æ€æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/strategy.html"><strong aria-hidden="true">22.</strong> ç­–ç•¥æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/template-method.html"><strong aria-hidden="true">23.</strong> æ¨¡æ¿æ–¹æ³•æ¨¡å¼</a></li><li class="chapter-item expanded "><a href="behavioral/visitor.html"><strong aria-hidden="true">24.</strong> è®¿é—®è€…æ¨¡å¼</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="others/model-and-algorithm.html"><strong aria-hidden="true">25.</strong> æ¨¡å‹ä¸ç®—æ³•</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Fortrançš„23ç§è®¾è®¡æ¨¡å¼</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/zoziha/Fortran-Design-Patterns/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fortrançš„23ç§è®¾è®¡æ¨¡å¼"><a class="header" href="#fortrançš„23ç§è®¾è®¡æ¨¡å¼">Fortrançš„23ç§è®¾è®¡æ¨¡å¼</a></h1>
<p><a href="LICENSE"><img src="https://img.shields.io/github/license/zoziha/Fortran-Design-Patterns?color=pink" alt="BSD-3" /></a>
<a href="https://github.com/zoziha/Fortran-Design-Patterns/actions"><img src="https://github.com/zoziha/Fortran-Design-Patterns/workflows/fpm/badge.svg" alt="fpm" /></a>
<a href="https://github.com/zoziha/Fortran-Design-Patterns/actions"><img src="https://github.com/zoziha/Fortran-Design-Patterns/workflows/mdbook/badge.svg" alt="mdbook" /></a>
<a href="https://wakatime.com/@ca8e3153-da86-47e8-ba89-1fac0c842c19"><img src="https://wakatime.com/badge/user/ca8e3153-da86-47e8-ba89-1fac0c842c19.svg" alt="wakatime" /></a></p>
<p>ã€ŠFortrançš„23ç§è®¾è®¡æ¨¡å¼ã€‹æ˜¯ä¸€ä»½Fortrané¢å‘å¯¹è±¡ç¼–ç¨‹ä¸­æ–‡å®ç”¨æ•™ç¨‹ã€‚</p>
<table><thead><tr><th align="center">é¡¹ç›®</th><th align="center">æè¿°</th></tr></thead><tbody>
<tr><td align="center">ç‰ˆæœ¬ï¼š</td><td align="center">0.1.0</td></tr>
<tr><td align="center">ä½œè€…ï¼š</td><td align="center">å·¦å¿—åï¼ˆzozihaï¼‰</td></tr>
<tr><td align="center">ç½‘é¡µï¼š</td><td align="center">https://zoziha.github.io/Fortran-Design-Patterns/</td></tr>
<tr><td align="center">ç‰ˆæƒï¼š</td><td align="center">Copyright (c) 2021~2022 zoziha</td></tr>
</tbody></table>
<h2 id="å¼€å§‹"><a class="header" href="#å¼€å§‹">å¼€å§‹</a></h2>
<h3 id="è½¯ä»¶ä¾èµ–"><a class="header" href="#è½¯ä»¶ä¾èµ–">è½¯ä»¶ä¾èµ–</a></h3>
<ul>
<li>Git</li>
<li><a href="https://github.com/fortran-lang/fpm">fortran-lang/fpm</a></li>
<li><a href="https://www.rust-lang.org/zh-CN/">Rust</a></li>
<li><a href="https://github.com/rust-lang/mdBook">mdbook</a></li>
</ul>
<h3 id="è·å–ä»£ç "><a class="header" href="#è·å–ä»£ç ">è·å–ä»£ç </a></h3>
<pre><code class="language-sh">git clone https://github.com/zoziha/Fortran-Design-Patterns.git
cd Fortran-Design-Patterns
</code></pre>
<h3 id="ä½¿ç”¨a-hrefhttpsgithubcomfortran-langfpmfortran-langfpmaæ„å»ºä»£ç "><a class="header" href="#ä½¿ç”¨a-hrefhttpsgithubcomfortran-langfpmfortran-langfpmaæ„å»ºä»£ç ">ä½¿ç”¨<a href="https://github.com/fortran-lang/fpm">fortran-lang/fpm</a>æ„å»ºä»£ç </a></h3>
<p>FortranåŒ…ç®¡ç†å™¨ï¼ˆfpmï¼‰æ˜¯Fortran-langç¤¾åŒºé©±åŠ¨ã€ä¸ºFortranç”Ÿæ€è®¾è®¡çš„åŒ…ç®¡ç†å™¨å’Œä»£ç æ„å»ºå™¨ã€‚
ä½ å¯ä»¥é€šè¿‡æä¾›çš„<code>fpm.toml</code>æ„å»ºä»£ç ï¼š</p>
<pre><code class="language-sh">fpm test --list  # è·å–å·²æä¾›çš„è®¾è®¡æ¨¡å¼ç¤ºä¾‹
fpm test &lt;pattern_name, see `fpm.toml` or test list&gt;
</code></pre>
<h3 id="ä½¿ç”¨a-hrefhttpsgithubcomrust-langmdbookmdbookaæ„å»ºæ–‡æ¡£"><a class="header" href="#ä½¿ç”¨a-hrefhttpsgithubcomrust-langmdbookmdbookaæ„å»ºæ–‡æ¡£">ä½¿ç”¨<a href="https://github.com/rust-lang/mdBook">mdbook</a>æ„å»ºæ–‡æ¡£</a></h3>
<p>mdBookæ˜¯ä¸€ä¸ªä»Markdownæ–‡ä»¶åˆ›å»ºç°ä»£åœ¨çº¿ä¹¦ç±çš„å®ç”¨ç¨‹åºã€‚
ä½ å¯ä»¥é€šè¿‡æä¾›çš„<code>book.toml</code>æ–‡ä»¶æ¥æ„å»ºã€ŠFortrançš„23ç§è®¾è®¡æ¨¡å¼ã€‹ã€‚</p>
<pre><code class="language-sh">cd doc &amp;&amp; mdbook build
</code></pre>
<h3 id="é“¾æ¥"><a class="header" href="#é“¾æ¥">é“¾æ¥</a></h3>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns">è®¾è®¡æ¨¡å¼</a></li>
<li><a href="https://github.com/farhanjk/FortranPatterns">farhanjk/FortranPatterns</a></li>
</ul>
<h2 id="å¼€æºè®¸å¯è¯"><a class="header" href="#å¼€æºè®¸å¯è¯">å¼€æºè®¸å¯è¯</a></h2>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2021~2022, å·¦å¿—å
All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li>
<p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li>
<p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li>
<p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortrançš„23ç§è®¾è®¡æ¨¡å¼-1"><a class="header" href="#fortrançš„23ç§è®¾è®¡æ¨¡å¼-1">Fortrançš„23ç§è®¾è®¡æ¨¡å¼</a></h1>
<p>è§†é¢‘é“¾æ¥ï¼šhttps://www.bilibili.com/video/BV1wU4y1E7xG?spm_id_from=333.999.0.0</p>
<p>è®¾è®¡æ¨¡å¼ï¼šhttps://refactoringguru.cn/design-patterns/go</p>
<p>Fortranä¸‰ç§ç¼–ç¨‹èŒƒå¼ï¼šhttps://zhuanlan.zhihu.com/p/412243161</p>
<p>åœ¨çº¿ç¼–è¯‘å™¨ï¼šhttps://godbolt.org/</p>
<p>é¢å‘å¯¹è±¡ï¼šé¢å‘å¯¹è±¡çš„<strong>å†…æ ¸æ˜¯ä¼ é€’ä¿¡æ¯</strong>ï¼Œä»¥å¯¹è±¡ï¼ˆç»“æ„ä½“ï¼‰ä¸ºè½½ä½“ï¼Œå®ƒæ˜¯å»ºæ¨¡ç›´è§‚çš„ã€‚</p>
<p>è®¾è®¡æ¨¡å¼ï¼šæ¨¡å¼çš„æ¦‚å¿µæ˜¯ç”±å…‹é‡Œæ–¯æ‰˜ä½›Â·äºšå†å±±å¤§åœ¨å…¶è‘—ä½œã€Šå»ºç­‘æ¨¡å¼è¯­è¨€ã€‹ä¸­é¦–æ¬¡æå‡ºçš„ã€‚<strong>æ¨¡å¼å¯å¤ç”¨</strong>ï¼Œé™¤éæœ‰å¿…è¦ï¼Œä¸å¿…é‡æ–°æ€è€ƒæ¨¡å¼ã€‚</p>
<h2 id="è®¾è®¡æ¨¡å¼åˆ—è¡¨"><a class="header" href="#è®¾è®¡æ¨¡å¼åˆ—è¡¨">è®¾è®¡æ¨¡å¼åˆ—è¡¨</a></h2>
<table><thead><tr><th align="center">çŠ¶æ€</th><th align="center">åˆ›å»ºå‹æ¨¡å¼</th><th align="center">ç»“æ„å‹æ¨¡å¼</th><th align="center">è¡Œä¸ºæ¨¡å¼</th></tr></thead><tbody>
<tr><td align="center">å®Œæˆ</td><td align="center">æŠ½è±¡å·¥å‚ã€ç”Ÿæˆå™¨ã€å·¥å‚æ–¹æ³•ã€åŸå‹ã€å•ä¾‹ã€‚</td><td align="center">é€‚é…å™¨ã€æ¡¥æ¥ã€ç»„åˆã€è£…é¥°ã€å¤–è§‚ã€ä»£ç†ã€äº«å…ƒã€‚</td><td align="center">è´£ä»»é“¾ã€å‘½ä»¤ã€è¿­ä»£å™¨ã€è§‚å¯Ÿè€…ã€çŠ¶æ€ã€æ¨¡æ¿æ–¹æ³•ã€å¤‡å¿˜å½•ã€ä¸­ä»‹è€…ã€è®¿é—®è€…ã€ç­–ç•¥ã€‚</td></tr>
</tbody></table>
<h4 id="åˆ›å»ºå‹æ¨¡å¼"><a class="header" href="#åˆ›å»ºå‹æ¨¡å¼">åˆ›å»ºå‹æ¨¡å¼</a></h4>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
æŠ½è±¡å·¥å‚</li>
<li><input disabled="" type="checkbox" checked=""/>
ç”Ÿæˆå™¨</li>
<li><input disabled="" type="checkbox" checked=""/>
å·¥å‚æ–¹æ³•</li>
<li><input disabled="" type="checkbox" checked=""/>
åŸå‹</li>
<li><input disabled="" type="checkbox" checked=""/>
å•ä¾‹</li>
</ul>
<h4 id="ç»“æ„å‹æ¨¡å¼"><a class="header" href="#ç»“æ„å‹æ¨¡å¼">ç»“æ„å‹æ¨¡å¼</a></h4>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
é€‚é…å™¨</li>
<li><input disabled="" type="checkbox" checked=""/>
æ¡¥æ¥</li>
<li><input disabled="" type="checkbox" checked=""/>
ç»„åˆ</li>
<li><input disabled="" type="checkbox" checked=""/>
è£…é¥°</li>
<li><input disabled="" type="checkbox" checked=""/>
å¤–è§‚</li>
<li><input disabled="" type="checkbox" checked=""/>
äº«å…ƒ</li>
<li><input disabled="" type="checkbox" checked=""/>
ä»£ç†</li>
</ul>
<h4 id="è¡Œä¸ºæ¨¡å¼"><a class="header" href="#è¡Œä¸ºæ¨¡å¼">è¡Œä¸ºæ¨¡å¼</a></h4>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
è´£ä»»é“¾</li>
<li><input disabled="" type="checkbox" checked=""/>
å‘½ä»¤</li>
<li><input disabled="" type="checkbox" checked=""/>
è¿­ä»£å™¨</li>
<li><input disabled="" type="checkbox" checked=""/>
ä¸­ä»‹è€…</li>
<li><input disabled="" type="checkbox" checked=""/>
å¤‡å¿˜å½•</li>
<li><input disabled="" type="checkbox" checked=""/>
è§‚å¯Ÿè€…</li>
<li><input disabled="" type="checkbox" checked=""/>
çŠ¶æ€</li>
<li><input disabled="" type="checkbox" checked=""/>
ç­–ç•¥</li>
<li><input disabled="" type="checkbox" checked=""/>
æ¨¡æ¿æ–¹æ³•</li>
<li><input disabled="" type="checkbox" checked=""/>
è®¿é—®è€…</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æŠ½è±¡å·¥å‚æ¨¡å¼"><a class="header" href="#æŠ½è±¡å·¥å‚æ¨¡å¼">æŠ½è±¡å·¥å‚æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/abstract-factory</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/abstract-factory/go/example</p>
<p>ç‚¹è¯„ï¼šæ˜¾ç„¶æ˜“è§ï¼ŒæŠ½è±¡å·¥å‚è®¾è®¡æ¨¡å¼ç¼ºç‚¹ä¹‹ä¸€æ˜¯ï¼Œå‘åº”ç”¨ä¸­å¼•å…¥ä¼—å¤šçš„æ¥å£å’Œç±»ï¼Œä»£ç å¯èƒ½ä¼šå› æ­¤å˜å¾—æ›´åŠ å¤æ‚ã€‚</p>
<pre><code class="language-fortran">module abstract_factory_module

    use, intrinsic :: iso_fortran_env, only: int8
    implicit none
    private

    public :: isports_factory_t, erke_t, lining_t, get_sports_factory, erke_shoe_t, erke_shirt_t, &amp;
              lining_shoe_t, lining_shirt_t, ishoe_t, ishirt_t

    !&gt; Abstract classes
    type, abstract :: isports_factory_t
    contains
        procedure(isports_factory_t_make_shoe), deferred :: make_shoe
        procedure(isports_factory_t_make_shirt), deferred :: make_shirt
    end type isports_factory_t

    type, abstract :: ishoe_t
    contains
        procedure(ishoe_t_set_logo), deferred :: set_logo
        procedure(ishoe_t_set_size), deferred :: set_size
        procedure(ishoe_t_get_logo), deferred :: get_logo
        procedure(ishoe_t_get_size), deferred :: get_size
    end type ishoe_t

    type, abstract :: ishirt_t
    contains
        procedure(ishirt_t_set_logo), deferred :: set_logo
        procedure(ishirt_t_set_size), deferred :: set_size
        procedure(ishirt_t_get_logo), deferred :: get_logo
        procedure(ishirt_t_get_size), deferred :: get_size
    end type ishirt_t

    abstract interface

        function isports_factory_t_make_shoe(self) result(shoe)
            import isports_factory_t, ishoe_t
            class(isports_factory_t), intent(inout) :: self
            class(ishoe_t), allocatable :: shoe
        end function isports_factory_t_make_shoe
        function isports_factory_t_make_shirt(self) result(shirt)
            import isports_factory_t, ishirt_t
            class(isports_factory_t), intent(inout) :: self
            class(ishirt_t), allocatable :: shirt
        end function isports_factory_t_make_shirt

        subroutine ishoe_t_set_logo(self, logo)
            import ishoe_t
            class(ishoe_t), intent(inout) :: self
            character(*), intent(in) :: logo
        end subroutine ishoe_t_set_logo
        subroutine ishoe_t_set_size(self, size)
            import ishoe_t, int8
            class(ishoe_t), intent(inout) :: self
            integer(int8), intent(in) :: size
        end subroutine ishoe_t_set_size
        function ishoe_t_get_logo(self) result(logo)
            import ishoe_t
            class(ishoe_t), intent(inout) :: self
            character(:), allocatable :: logo
        end function ishoe_t_get_logo
        function ishoe_t_get_size(self) result(size)
            import ishoe_t, int8
            class(ishoe_t), intent(inout) :: self
            integer(int8) :: size
        end function ishoe_t_get_size

        subroutine ishirt_t_set_logo(self, logo)
            import ishirt_t
            class(ishirt_t), intent(inout) :: self
            character(*), intent(in) :: logo
        end subroutine ishirt_t_set_logo
        subroutine ishirt_t_set_size(self, size)
            import ishirt_t, int8
            class(ishirt_t), intent(inout) :: self
            integer(int8), intent(in) :: size
        end subroutine ishirt_t_set_size
        function ishirt_t_get_logo(self) result(logo)
            import ishirt_t
            class(ishirt_t), intent(inout) :: self
            character(:), allocatable :: logo
        end function ishirt_t_get_logo
        function ishirt_t_get_size(self) result(size)
            import ishirt_t, int8
            class(ishirt_t), intent(inout) :: self
            integer(int8) :: size
        end function ishirt_t_get_size

    end interface

    !&gt; Specific objects

    type, extends(isports_factory_t) :: erke_t
    contains
        procedure :: make_shoe =&gt; erke_t_make_shoe
        procedure :: make_shirt =&gt; erke_t_make_shirt
    end type erke_t

    type, extends(isports_factory_t) :: lining_t
    contains
        procedure :: make_shoe =&gt; lining_t_make_shoe
        procedure :: make_shirt =&gt; lining_t_make_shirt
    end type lining_t

    type, extends(ishoe_t) :: shoe_t
        character(:), allocatable :: logo
        integer(int8) :: size
    contains
        procedure :: set_logo =&gt; shoe_t_set_logo
        procedure :: set_size =&gt; shoe_t_set_size
        procedure :: get_logo =&gt; shoe_t_get_logo
        procedure :: get_size =&gt; shoe_t_get_size
    end type shoe_t

    type, extends(ishirt_t) :: shirt_t
        character(:), allocatable :: logo
        integer(int8) :: size
    contains
        procedure :: set_logo =&gt; shirt_t_set_logo
        procedure :: set_size =&gt; shirt_t_set_size
        procedure :: get_logo =&gt; shirt_t_get_logo
        procedure :: get_size =&gt; shirt_t_get_size
    end type shirt_t

    type, extends(shoe_t) :: erke_shoe_t
    end type erke_shoe_t

    type, extends(shoe_t) :: lining_shoe_t
    end type lining_shoe_t

    type, extends(shirt_t) :: erke_shirt_t
    end type erke_shirt_t

    type, extends(shirt_t) :: lining_shirt_t
    end type lining_shirt_t

contains

    function get_sports_factory(brand) result(isports_factory)
        character(*), intent(in) :: brand
        class(isports_factory_t), allocatable :: isports_factory

        select case (brand)
        case (&quot;erke&quot;)
            isports_factory = erke_t()
        case (&quot;lining&quot;)
            isports_factory = lining_t()
        case default
            error stop &quot;*&lt;ERROR&gt;* Brand not supported.&quot;
        end select

    end function get_sports_factory

    function erke_t_make_shoe(self) result(shoe)
        class(erke_t), intent(inout) :: self
        class(ishoe_t), allocatable :: shoe

        shoe = erke_shoe_t(logo=&quot;erke&quot;, size=15_int8)

    end function erke_t_make_shoe

    function erke_t_make_shirt(self) result(shirt)
        class(erke_t), intent(inout) :: self
        class(ishirt_t), allocatable :: shirt

        shirt = erke_shirt_t(logo=&quot;erke&quot;, size=84_int8)

    end function erke_t_make_shirt

    function lining_t_make_shoe(self) result(shoe)
        class(lining_t), intent(inout) :: self
        class(ishoe_t), allocatable :: shoe

        shoe = lining_shoe_t(logo=&quot;lining&quot;, size=14_int8)

    end function lining_t_make_shoe

    function lining_t_make_shirt(self) result(shirt)
        class(lining_t), intent(inout) :: self
        class(ishirt_t), allocatable :: shirt

        shirt = lining_shirt_t(logo=&quot;lining&quot;, size=85_int8)

    end function lining_t_make_shirt

    subroutine shoe_t_set_logo(self, logo)
        class(shoe_t), intent(inout) :: self
        character(*), intent(in) :: logo

        self%logo = logo

    end subroutine shoe_t_set_logo

    subroutine shoe_t_set_size(self, size)
        class(shoe_t), intent(inout) :: self
        integer(int8), intent(in) :: size

        self%size = size

    end subroutine shoe_t_set_size

    function shoe_t_get_logo(self) result(logo)
        class(shoe_t), intent(inout) :: self
        character(:), allocatable :: logo

        logo = self%logo

    end function shoe_t_get_logo

    function shoe_t_get_size(self) result(size)
        class(shoe_t), intent(inout) :: self
        integer(int8) :: size

        size = self%size

    end function shoe_t_get_size

    subroutine shirt_t_set_logo(self, logo)
        class(shirt_t), intent(inout) :: self
        character(*), intent(in) :: logo

        self%logo = logo

    end subroutine shirt_t_set_logo

    subroutine shirt_t_set_size(self, size)
        class(shirt_t), intent(inout) :: self
        integer(int8), intent(in) :: size

        self%size = size

    end subroutine shirt_t_set_size

    function shirt_t_get_logo(self) result(logo)
        class(shirt_t), intent(inout) :: self
        character(:), allocatable :: logo

        logo = self%logo

    end function shirt_t_get_logo

    function shirt_t_get_size(self) result(size)
        class(shirt_t), intent(inout) :: self
        integer(int8) :: size

        size = self%size

    end function shirt_t_get_size

end module abstract_factory_module
</code></pre>
<pre><code class="language-fortran">program abstract_factory_main

    use, intrinsic :: iso_fortran_env, only: int8
    use abstract_factory_module, only: isports_factory_t, erke_t, lining_t, get_sports_factory, erke_shoe_t, erke_shirt_t, &amp;
                                       lining_shoe_t, lining_shirt_t, ishoe_t, ishirt_t

    class(isports_factory_t), allocatable :: erke_factory, lining_factory
    class(ishoe_t), allocatable :: erke_shoe
    class(ishirt_t), allocatable :: erke_shirt
    class(ishoe_t), allocatable :: lining_shoe
    class(ishirt_t), allocatable :: lining_shirt

    ! allocate (erke_t :: erke_factory)
    ! allocate (lining_t :: lining_factory)

    erke_factory = get_sports_factory(&quot;erke&quot;)
    lining_factory = get_sports_factory(&quot;lining&quot;)

    ! allocate (erke_shoe_t :: erke_shoe)
    ! allocate (erke_shirt_t :: erke_shirt)
    ! allocate (lining_shoe_t :: lining_shoe)
    ! allocate (lining_shirt_t :: lining_shirt)

    erke_shoe = erke_factory%make_shoe()
    erke_shirt = erke_factory%make_shirt()

    lining_shoe = lining_factory%make_shoe()
    lining_shirt = lining_factory%make_shirt()

    call print_shoe_details(erke_shoe)
    call print_shirt_details(erke_shirt)

    call print_shoe_details(lining_shoe)
    call print_shirt_details(lining_shirt)

contains

    subroutine print_shoe_details(ishoe)
        class(ishoe_t), intent(inout) :: ishoe

        print *, &quot;This is a pair of shoesğŸ‘Ÿ.&quot;
        print *, &quot;Logo: &quot;, ishoe%get_logo()
        print *, &quot;Size: &quot;, ishoe%get_size()

    end subroutine print_shoe_details

    subroutine print_shirt_details(ishirt)
        class(ishirt_t), intent(inout) :: ishirt

        print *, &quot;This is a T-shirtğŸ‘•.&quot;
        print *, &quot;Logo: &quot;, ishirt%get_logo()
        print *, &quot;Size: &quot;, ishirt%get_size()

    end subroutine print_shirt_details

end program abstract_factory_main

!&gt; Results shall be:

!  This is a pair of shoesğŸ‘Ÿ.
!  Logo: erke
!  Size:    14
!  This is a T-shirtğŸ‘•.
!  Logo: erke
!  Size:    14
!  This is a pair of shoesğŸ‘Ÿ.
!  Logo: lining
!  Size:    14
!  This is a T-shirtğŸ‘•.
!  Logo: lining
!  Size:    14
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç”Ÿæˆå™¨æ¨¡å¼"><a class="header" href="#ç”Ÿæˆå™¨æ¨¡å¼">ç”Ÿæˆå™¨æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/builder</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/builder/go/example</p>
<pre><code class="language-fortran">module builder_module

    use, intrinsic :: iso_fortran_env, only: int8
    implicit none
    private

    public :: ibuilder_t, director_t, house_t, get_builder

    type, abstract :: ibuilder_t
    contains
        procedure(ibuilder_t_set_window_type), deferred :: set_window_type
        procedure(ibuilder_t_set_door_type), deferred :: set_door_type
        procedure(ibuilder_t_set_num_floor), deferred :: set_num_floor
        procedure(ibuilder_t_get_house), deferred :: get_house
    end type ibuilder_t

    type, extends(ibuilder_t) :: normal_builder_t
        character(:), allocatable :: window_type
        character(:), allocatable :: door_type
        integer(int8) :: floor
    contains
        procedure :: set_window_type =&gt; normal_builder_t_set_window_type
        procedure :: set_door_type =&gt; normal_builder_t_set_door_type
        procedure :: set_num_floor =&gt; normal_builder_t_set_num_floor
        procedure :: get_house =&gt; normal_builder_t_get_house
    end type normal_builder_t

    type, extends(ibuilder_t) :: igloo_builder_t
        character(:), allocatable :: window_type
        character(:), allocatable :: door_type
        integer(int8) :: floor
    contains
        procedure :: set_window_type =&gt; igloo_builder_t_set_window_type
        procedure :: set_door_type =&gt; igloo_builder_t_set_door_type
        procedure :: set_num_floor =&gt; igloo_builder_t_set_num_floor
        procedure :: get_house =&gt; igloo_builder_t_get_house
    end type igloo_builder_t

    type house_t
        character(:), allocatable :: window_type
        character(:), allocatable :: door_type
        integer(int8) :: floor
    end type house_t

    type director_t
        class(ibuilder_t), pointer :: builder
    contains
        procedure :: set_builder =&gt; director_t_set_builder
        procedure :: build_house =&gt; director_t_build_house
    end type director_t

    abstract interface

        subroutine ibuilder_t_set_window_type(self)
            import ibuilder_t
            class(ibuilder_t), intent(inout) :: self
        end subroutine ibuilder_t_set_window_type

        subroutine ibuilder_t_set_door_type(self)
            import ibuilder_t
            class(ibuilder_t), intent(inout) :: self
        end subroutine ibuilder_t_set_door_type

        subroutine ibuilder_t_set_num_floor(self)
            import ibuilder_t
            class(ibuilder_t), intent(inout) :: self
        end subroutine ibuilder_t_set_num_floor

        function ibuilder_t_get_house(self) result(house)
            import ibuilder_t, house_t
            class(ibuilder_t), intent(inout) :: self
            type(house_t) :: house
        end function ibuilder_t_get_house

    end interface

contains

    function get_builder(builder_type) result(ibuilder)
        character(*), intent(in) :: builder_type
        class(ibuilder_t), allocatable :: ibuilder
        select case (builder_type)
        case (&quot;normal&quot;)
            allocate (normal_builder_t :: ibuilder)
        case (&quot;igloo&quot;)
            allocate (igloo_builder_t :: ibuilder)
        end select
    end function get_builder

    ! - - - - - - - - - -

    subroutine normal_builder_t_set_window_type(self)
        class(normal_builder_t), intent(inout) :: self
        self%window_type = &quot;Wooden Window&quot;
    end subroutine normal_builder_t_set_window_type

    subroutine normal_builder_t_set_door_type(self)
        class(normal_builder_t), intent(inout) :: self
        self%door_type = &quot;Wooden Door&quot;
    end subroutine normal_builder_t_set_door_type

    subroutine normal_builder_t_set_num_floor(self)
        class(normal_builder_t), intent(inout) :: self
        self%floor = 2_int8
    end subroutine normal_builder_t_set_num_floor

    function normal_builder_t_get_house(self) result(house)
        class(normal_builder_t), intent(inout) :: self
        type(house_t) :: house
        ! TODO: A GFortran Bug Here.
        ! house = house_t(door_type=self%door_type, &amp;
        !                 window_type=self%window_type, &amp;
        !                 floor=self%floor)
        house%door_type = self%door_type
        house%window_type = self%window_type
        house%floor = self%floor
    end function normal_builder_t_get_house

    ! - - - - - - - - - -

    subroutine igloo_builder_t_set_window_type(self)
        class(igloo_builder_t), intent(inout) :: self
        self%window_type = &quot;Snow Window&quot;
    end subroutine igloo_builder_t_set_window_type

    subroutine igloo_builder_t_set_door_type(self)
        class(igloo_builder_t), intent(inout) :: self
        self%door_type = &quot;Snow Door&quot;
    end subroutine igloo_builder_t_set_door_type

    subroutine igloo_builder_t_set_num_floor(self)
        class(igloo_builder_t), intent(inout) :: self
        self%floor = 1_int8
    end subroutine igloo_builder_t_set_num_floor

    function igloo_builder_t_get_house(self) result(house)
        class(igloo_builder_t), intent(inout) :: self
        type(house_t) :: house
        ! house = house_t(door_type=self%door_type, &amp;
        !                 window_type=self%window_type, &amp;
        !                 floor=self%floor)
        house%door_type = self%door_type
        house%window_type = self%window_type
        house%floor = self%floor
    end function igloo_builder_t_get_house

    ! - - - - - - - - - -

    subroutine director_t_set_builder(self, b)
        class(director_t), intent(inout) :: self
        class(ibuilder_t), intent(inout), target :: b
        self%builder =&gt; b
    end subroutine director_t_set_builder

    function director_t_build_house(self) result(house)
        class(director_t), intent(inout) :: self
        type(house_t) :: house
        call self%builder%set_door_type()
        call self%builder%set_window_type()
        call self%builder%set_num_floor()
        house = self%builder%get_house()
    end function director_t_build_house

end module builder_module
</code></pre>
<pre><code class="language-fortran">program builder_main
    use builder_module, only: ibuilder_t, director_t, house_t, get_builder
    implicit none

    class(ibuilder_t), allocatable :: normal_builder, igloo_builder
    type(director_t) :: director
    type(house_t) :: normal_house, igloo_house

    normal_builder = get_builder(&quot;normal&quot;)
    igloo_builder = get_builder(&quot;igloo&quot;)

    !&gt; Normal House
    call director%set_builder(normal_builder)
    normal_house = director%build_house()

    print *, &quot;Normal House Door Type: &quot;, normal_house%door_type
    print *, &quot;Normal House Window Type: &quot;, normal_house%window_type
    print *, &quot;Normal House Num Floor: &quot;, normal_house%floor

    !&gt; Igloo House
    call director%set_builder(igloo_builder)
    igloo_house = director%build_house()

    print *, &quot;Igloo House Door Type: &quot;, igloo_house%door_type
    print *, &quot;Igloo House Window Type: &quot;, igloo_house%window_type
    print *, &quot;Igloo House Num Floor: &quot;, igloo_house%floor

end program builder_main

!&gt; Results shall be:

!  Normal House Door Type: Wooden Door
!  Normal House Window Type: Wooden Window
!  Normal House Num Floor:     2
!  Igloo House Door Type: Snow Door
!  Igloo House Window Type: Snow Window
!  Igloo House Num Floor:     1
</code></pre>
<p>ä½¿ç”¨é»˜è®¤ç»“æ„ä½“æ„é€ å‡½æ•°æ¥èµ‹å€¼å¯åˆ†é…å­—ç¬¦å‹ç±»å‹çš„å­å…ƒç´ ï¼Œåœ¨GFortranä¸Šå‡ºç°bugï¼Œifortæ­£å¸¸ï¼š</p>
<pre><code class="language-fortran">        ! TODO: A GFortran Bug Here.
        ! house = house_t(door_type=self%door_type, &amp;
        !                 window_type=self%window_type, &amp;
        !                 floor=self%floor)
        house%door_type = self%door_type
        house%window_type = self%window_type
        house%floor = self%floor
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å·¥å‚æ¨¡å¼"><a class="header" href="#å·¥å‚æ¨¡å¼">å·¥å‚æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/factory</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/factory/go/example</p>
<pre><code class="language-fortran">module factory_module

    use, intrinsic :: iso_fortran_env, only: int8
    implicit none
    private

    public :: igun_t, ak47_t, musket_t, get_gun

    type, abstract :: igun_t
    contains
        procedure(igun_t_set_name), deferred :: set_name
        procedure(igun_t_set_power), deferred :: set_power
        procedure(igun_t_get_name), deferred :: get_name
        procedure(igun_t_get_power), deferred :: get_power
    end type igun_t

    abstract interface

        subroutine igun_t_set_name(self, name)
            import igun_t
            class(igun_t), intent(inout) :: self
            character(*), intent(in) :: name
        end subroutine igun_t_set_name

        subroutine igun_t_set_power(self, power)
            import igun_t, int8
            class(igun_t), intent(inout) :: self
            integer(int8), intent(in) :: power
        end subroutine igun_t_set_power

        function igun_t_get_name(self) result(name)
            import igun_t
            class(igun_t), intent(inout) :: self
            character(:), allocatable :: name
        end function igun_t_get_name

        function igun_t_get_power(self) result(power)
            import igun_t, int8
            class(igun_t), intent(inout) :: self
            integer(int8) :: power
        end function igun_t_get_power

    end interface

    type, extends(igun_t) :: gun_t
        character(:), allocatable :: name
        integer(int8) :: power
    contains
        procedure :: set_name =&gt; gun_t_set_name
        procedure :: get_name =&gt; gun_t_get_name
        procedure :: set_power =&gt; gun_t_set_power
        procedure :: get_power =&gt; gun_t_get_power
    end type gun_t

    type, extends(gun_t) :: ak47_t
    end type ak47_t

    type, extends(gun_t) :: musket_t
    end type musket_t

contains

    subroutine gun_t_set_name(self, name)
        class(gun_t), intent(inout) :: self
        character(*), intent(in) :: name
        self%name = name
    end subroutine gun_t_set_name

    subroutine gun_t_set_power(self, power)
        class(gun_t), intent(inout) :: self
        integer(int8), intent(in) :: power
        self%power = power
    end subroutine gun_t_set_power

    function gun_t_get_name(self) result(name)
        class(gun_t), intent(inout) :: self
        character(:), allocatable :: name
        name = self%name
    end function gun_t_get_name

    function gun_t_get_power(self) result(power)
        class(gun_t), intent(inout) :: self
        integer(int8) :: power
        power = self%power
    end function gun_t_get_power

    function get_gun(gun_type) result(igun)
        character(*), intent(in) :: gun_type
        class(igun_t), allocatable :: igun

        select case (gun_type)
        case (&quot;ak47&quot;)
            igun = ak47_t(name=&quot;ak47 gun&quot;, power=4)
        case (&quot;musket&quot;)
            igun = musket_t(name=&quot;musket gun&quot;, power=1)
        case default
            error stop &quot;*ERROR* `gnu_type` not supported&quot;
        end select

    end function get_gun

end module factory_module
</code></pre>
<pre><code class="language-fortran">program factory_main

    use factory_module, only: igun_t, ak47_t, musket_t, get_gun
    implicit none

    class(igun_t), allocatable :: ak47, musket

    allocate (ak47_t :: ak47)
    allocate (musket_t :: musket)

    ak47 = get_gun(&quot;ak47&quot;)
    musket = get_gun(&quot;musket&quot;)

    call print_details(ak47)
    call print_details(musket)

contains

    subroutine print_details(igun)
        class(igun_t), intent(inout) :: igun
        print *, &quot;Gun: &quot;, igun%get_name()
        print *, &quot;Power: &quot;, igun%get_power()
    end subroutine print_details

end program factory_main

!&gt; Results shall be:

!  Gun: ak47 gun
!  Power:     4
!  Gun: musket gun
!  Power:     1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="åŸå‹æ¨¡å¼"><a class="header" href="#åŸå‹æ¨¡å¼">åŸå‹æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/prototype</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/prototype/go/example</p>
<pre><code class="language-fortran">module prototype_module

    implicit none
    private

    public :: file_t, folder_t, inode_t

    type, abstract :: inode_t
    contains
        procedure(inode_t_print), deferred :: print
        procedure(inode_t_clone), deferred :: clone
    end type inode_t

    type, extends(inode_t) :: file_t
        character(:), allocatable :: name
    contains
        procedure :: print =&gt; file_t_print
        procedure :: clone =&gt; file_t_clone
    end type file_t

    !&gt; Wrapper (Important)
    type node_t
        class(inode_t), pointer :: inode
    end type node_t

    type, extends(inode_t) :: folder_t
        type(node_t), allocatable :: children(:)
        character(:), allocatable :: name
    contains
        procedure :: print =&gt; folder_t_print
        procedure :: clone =&gt; folder_t_clone
    end type folder_t

    abstract interface

        subroutine inode_t_print(self, indentation)
            import inode_t
            class(inode_t), intent(inout) :: self
            character(*), intent(in) :: indentation
        end subroutine inode_t_print

        function inode_t_clone(self) result(inode)
            import inode_t
            class(inode_t), intent(inout) :: self
            class(inode_t), allocatable :: inode
        end function inode_t_clone

    end interface

contains

    subroutine file_t_print(self, indentation)
        class(file_t), intent(inout) :: self
        character(*), intent(in) :: indentation
        print *, indentation//self%name
    end subroutine file_t_print

    function file_t_clone(self) result(inode)
        class(file_t), intent(inout) :: self
        class(inode_t), allocatable :: inode
        allocate (file_t :: inode)
        inode = file_t(name=self%name//&quot;_clone&quot;)
    end function file_t_clone

    ! - - - - - - - - -

    subroutine folder_t_print(self, indentation)
        class(folder_t), intent(inout) :: self
        character(*), intent(in) :: indentation
        integer :: i
        print *, indentation//self%name
        if (size(self%children) == 0) return
        do i = 1, size(self%children)
            call self%children(i)%inode%print(indentation//indentation)
        end do
    end subroutine folder_t_print

    !&gt; There may be incorrect usage here, but I have no choice but to do so.
    !&gt;  Fortran's compilation check is stricter, and I am indeed bypassing it.
    function folder_t_clone(self) result(inode)
        class(folder_t), intent(inout) :: self
        class(inode_t), allocatable :: inode
        type(folder_t), allocatable :: tmp_folder
        integer :: i
        allocate (tmp_folder, source=self)
        tmp_folder%name = tmp_folder%name//&quot;_clone&quot;
        if (size(self%children) &gt; 0) then
        do i = 1, size(tmp_folder%children)
            associate (node =&gt; tmp_folder%children(i)%inode)
                inode = node%clone()
                allocate (tmp_folder%children(i)%inode, source=inode)
            end associate
        end do
        end if
        
        call move_alloc(tmp_folder, inode)
    end function folder_t_clone

end module prototype_module
</code></pre>
<pre><code class="language-fortran">program prototype_main
    use prototype_module, only: file_t, folder_t, inode_t
    implicit none
    type(file_t), target :: file1, file2, file3
    type(folder_t), target :: folder1
    type(folder_t) :: folder2
    class(inode_t), allocatable :: clone_folder

    file1%name = &quot;file1&quot;
    file2%name = &quot;file2&quot;
    file3%name = &quot;file3&quot;

    folder1%name = &quot;folder1&quot;
    allocate (folder1%children(1))
    folder1%children(1)%inode =&gt; file1

    folder2%name = &quot;folder2&quot;
    allocate (folder2%children(3))
    folder2%children(1)%inode =&gt; folder1
    folder2%children(2)%inode =&gt; file2
    folder2%children(3)%inode =&gt; file3

    print *, &quot;Printing hierarchy for Folder2&quot;
    call folder2%print(&quot;   &quot;)

    clone_folder = folder2%clone()
    print *, &quot;Printing hierarchy for clone Folder&quot;
    call clone_folder%print(&quot;   &quot;)

end program prototype_main

!&gt; Results shall be:

!  Printing hierarchy for Folder2
!     folder2
!        folder1
!              file1
!        file2
!        file3
!  Printing hierarchy for clone Folder
!     folder2_clone
!        folder1_clone
!              file1_clone
!        file2_clone
!        file3_clone
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å•ä¾‹æ¨¡å¼"><a class="header" href="#å•ä¾‹æ¨¡å¼">å•ä¾‹æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/singleton</p>
<pre><code class="language-fortran">module singleton_module

    implicit none
    private

    public :: single, get_instance, dispose_instance

    logical :: lock = .false.

    type single_t
        private
        integer :: value
    end type single_t

    type(single_t) :: single

contains

    function get_instance(value) result(single)
        integer, intent(in) :: value
        type(single_t) :: single
        if (lock) then
            print *, &quot;Single instance already created.&quot;
            return
        else
            print *, &quot;Creating single instance now.&quot;
            single%value = value
            lock = .true.
        end if
    end function get_instance

    subroutine dispose_instance(single)
        type(single_t), intent(inout) :: single
        print *, &quot;Disposing single instance now.&quot;
        single%value = 0
        lock = .false.
    end subroutine dispose_instance

end module singleton_module
</code></pre>
<pre><code class="language-fortran">program singleton_main

    use singleton_module, only: single, get_instance, dispose_instance
    implicit none

    single = get_instance(10)
    single = get_instance(23)
    single = get_instance(0)
    call dispose_instance(single)
    single = get_instance(9)

end program singleton_main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="é€‚é…å™¨æ¨¡å¼"><a class="header" href="#é€‚é…å™¨æ¨¡å¼">é€‚é…å™¨æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/adapter</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/adapter/go/example</p>
<pre><code class="language-fortran">module adapter_module

    implicit none
    private

    public :: client_t, computer_t, mac_t, windows_t, windows_adapter_t

    type client_t
    contains
        procedure :: insert_lightning_connector_into_computer =&gt; client_t_insert_lightning_connector_into_computer
    end type client_t

    type, abstract :: computer_t
    contains
        procedure(computer_t_insert_into_lightning_port), deferred :: insert_into_lightning_port
    end type computer_t

    type, extends(computer_t) :: mac_t
    contains
        procedure :: insert_into_lightning_port =&gt; mac_t_insert_into_lightning_port
    end type mac_t

    type, extends(computer_t) :: windows_t
    contains
        procedure :: insert_into_lightning_port =&gt; windows_t_insert_into_lightning_port
    end type windows_t

    type, extends(computer_t) :: windows_adapter_t
        type(windows_t), pointer :: windows_machine
    contains
        procedure :: insert_into_lightning_port =&gt; windows_adapter_t_insert_into_lightning_port
    end type windows_adapter_t

    abstract interface
        subroutine computer_t_insert_into_lightning_port(self)
            import computer_t
            class(computer_t), intent(inout) :: self
        end subroutine computer_t_insert_into_lightning_port
    end interface

contains

    subroutine client_t_insert_lightning_connector_into_computer(self, com)
        class(client_t), intent(inout) :: self
        class(computer_t), intent(inout) :: com
        print *, &quot;Client inserts Lightning connector into computer.&quot;
        call com%insert_into_lightning_port()
    end subroutine client_t_insert_lightning_connector_into_computer

    subroutine mac_t_insert_into_lightning_port(self)
        class(mac_t), intent(inout) :: self
        print *, &quot;Lightning connector is plugged into mac machine.&quot;
    end subroutine mac_t_insert_into_lightning_port

    subroutine windows_t_insert_into_lightning_port(self)
        class(windows_t), intent(inout) :: self
        print *, &quot;USB connector is plugged into windows machine.&quot;
    end subroutine windows_t_insert_into_lightning_port

    subroutine windows_adapter_t_insert_into_lightning_port(self)
        class(windows_adapter_t), intent(inout) :: self
        print *, &quot;Adapter converts Lightning signal to USB.&quot;
        call self%windows_machine%insert_into_lightning_port()
    end subroutine windows_adapter_t_insert_into_lightning_port

end module adapter_module
</code></pre>
<pre><code class="language-fortran">program adapter_main
    use adapter_module, only: client_t, computer_t, mac_t, windows_t, windows_adapter_t
    implicit none
    type(client_t) :: client
    type(mac_t) :: mac
    type(windows_t), target :: windows
    type(windows_adapter_t) :: windows_adapter

    call client%insert_lightning_connector_into_computer(mac)
    windows_adapter%windows_machine =&gt; windows
    call client%insert_lightning_connector_into_computer(windows_adapter)

end program adapter_main

!&gt; Results shall be:

!  Client inserts Lightning connector into computer.
!  Lightning connector is plugged into mac machine.
!  Client inserts Lightning connector into computer.
!  Adapter converts Lightning signal to USB.
!  USB connector is plugged into windows machine.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¡¥æ¥æ¨¡å¼"><a class="header" href="#æ¡¥æ¥æ¨¡å¼">æ¡¥æ¥æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/bridge</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/bridge/go/example</p>
<pre><code class="language-fortran">module bridge_module

    implicit none
    private

    public :: hp_t, epson_t, mac_t, windows_t

    type, abstract :: computer_t
    contains
        procedure(computer_t_print), deferred :: print
        procedure(computer_t_set_printer), deferred :: set_printer
    end type computer_t

    type, abstract :: printer_t
    contains
        procedure(printer_t_print_file), deferred :: print_file
    end type printer_t

    abstract interface

        subroutine computer_t_print(self)
            import computer_t
            class(computer_t), intent(inout) :: self
        end subroutine computer_t_print

        subroutine computer_t_set_printer(self, printer)
            import computer_t, printer_t
            class(computer_t), intent(inout) :: self
            class(printer_t), intent(inout), target :: printer
        end subroutine computer_t_set_printer

        subroutine printer_t_print_file(self)
            import printer_t
            class(printer_t), intent(inout) :: self
        end subroutine printer_t_print_file

    end interface

    type, extends(printer_t) :: epson_t
    contains
        procedure :: print_file =&gt; epson_t_print_file
    end type epson_t

    type, extends(printer_t) :: hp_t
    contains
        procedure :: print_file =&gt; hp_t_print_file
    end type hp_t

    type, extends(computer_t) :: mac_t
        class(printer_t), pointer :: printer
    contains
        procedure :: print =&gt; mac_t_print
        procedure :: set_printer =&gt; mac_t_set_printer
    end type mac_t

    type, extends(computer_t) :: windows_t
        class(printer_t), pointer :: printer
    contains
        procedure :: print =&gt; windows_t_print
        procedure :: set_printer =&gt; windows_t_set_printer
    end type windows_t

contains

    subroutine windows_t_print(self)
        class(windows_t), intent(inout) :: self
        print *, &quot;Print request for windows&quot;
        call self%printer%print_file()
    end subroutine windows_t_print

    subroutine windows_t_set_printer(self, printer)
        class(windows_t), intent(inout) :: self
        class(printer_t), intent(inout), target :: printer
        self%printer =&gt; printer
    end subroutine windows_t_set_printer

    subroutine mac_t_print(self)
        class(mac_t), intent(inout) :: self
        print *, &quot;Print request for mac&quot;
        call self%printer%print_file()
    end subroutine mac_t_print

    subroutine mac_t_set_printer(self, printer)
        class(mac_t), intent(inout) :: self
        class(printer_t), intent(inout), target :: printer
        self%printer =&gt; printer
    end subroutine mac_t_set_printer

    subroutine epson_t_print_file(self)
        class(epson_t), intent(inout) :: self
        print *, &quot;Printing by a EPSON Printer&quot;
    end subroutine epson_t_print_file

    subroutine hp_t_print_file(self)
        class(hp_t), intent(inout) :: self
        print *, &quot;Printing by a HP Printer&quot;
    end subroutine hp_t_print_file

end module bridge_module
</code></pre>
<pre><code class="language-fortran">program bridge_main

    use bridge_module, only: hp_t, epson_t, mac_t, windows_t
    implicit none

    type(hp_t) :: hp_printer
    type(epson_t) :: epson_printer
    type(mac_t) :: mac_computer
    type(windows_t) :: windows_computer

    call mac_computer%set_printer(hp_printer)
    call mac_computer%print()

    call mac_computer%set_printer(epson_printer)
    call mac_computer%print()

    call windows_computer%set_printer(hp_printer)
    call windows_computer%print()

    call windows_computer%set_printer(epson_printer)
    call windows_computer%print()

end program bridge_main

!&gt; Results shall be:

!  Print request for mac
!  Printing by a HP Printer
!  Print request for mac
!  Printing by a EPSON Printer
!  Print request for windows
!  Printing by a HP Printer
!  Print request for windows
!  Printing by a EPSON Printer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="äº«å…ƒæ¨¡å¼"><a class="header" href="#äº«å…ƒæ¨¡å¼">äº«å…ƒæ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/flyweight</p>
<p>Goä»£ç ï¼šhttps://zhuanlan.zhihu.com/p/343999246</p>
<pre><code class="language-fortran">module cache_module

    implicit none
    private

    public :: cache_t, cache_factory_t

    type, abstract :: cache_t
    contains
        procedure(cache_t_operation), deferred :: operation
    end type cache_t

    abstract interface
        subroutine cache_t_operation(self)
            import cache_t
            class(cache_t), intent(inout) :: self
        end subroutine cache_t_operation
    end interface

    type, extends(cache_t) :: concrete_cache_t
        character(:), allocatable :: key
    contains
        procedure :: operation =&gt; concrete_cache_t_operation
    end type concrete_cache_t

    type node_t
        class(cache_t), allocatable :: cache
    end type node_t

    type cache_factory_t
        type(node_t), allocatable :: cache_list(:)
    contains
        procedure :: get_cache =&gt; cache_factory_t_get_cache
    end type cache_factory_t

contains

    subroutine concrete_cache_t_operation(self)
        class(concrete_cache_t), intent(inout) :: self
        print *, self%key
    end subroutine concrete_cache_t_operation

    function cache_factory_t_get_cache(self, key) result(cache)
        class(cache_factory_t), intent(inout), target :: self
        character(*), intent(in) :: key
        class(cache_t), pointer :: cache
        integer :: i

        if (allocated(self%cache_list)) then
            do i = 1, size(self%cache_list)
                associate (cache_ =&gt; self%cache_list(i)%cache)
                
                    select type (cache_)
                    type is (concrete_cache_t)
                        if (cache_%key == key) then
                            cache =&gt; self%cache_list(i)%cache
                            return
                        end if
                    end select
                    
                end associate
            end do
        end if

        self%cache_list = append_slice(self%cache_list, key)
        cache =&gt; self%cache_list(size(self%cache_list))%cache

    end function cache_factory_t_get_cache

    !&gt; Date structure
    function append_slice(cache_list_in, key) result(cache_list_out)
        type(node_t), intent(inout), allocatable :: cache_list_in(:)
        character(*), intent(in) :: key
        type(node_t), allocatable :: cache_list_out(:)
        integer :: i

        if (.not. allocated(cache_list_in)) then
            allocate (cache_list_out(1))
            allocate (cache_list_out(1)%cache, source=concrete_cache_t(key=key))
        else
            i = size(cache_list_in)
            allocate (cache_list_out(i + 1))
            cache_list_out(1:i) = cache_list_in
            allocate (cache_list_out(i + 1)%cache, source=concrete_cache_t(key=key))
        end if
    end function append_slice

end module cache_module
</code></pre>
<pre><code class="language-fortran">program cache_main

    use cache_module, only: cache_factory_t, cache_t
    implicit none
    type(cache_factory_t) factory
    class(cache_t), pointer :: cache

    cache =&gt; factory%get_cache(&quot;A&quot;)
    call cache%operation()

    cache =&gt; factory%get_cache(&quot;A&quot;)
    call cache%operation()

    cache =&gt; factory%get_cache(&quot;B&quot;)
    call cache%operation()

    cache =&gt; factory%get_cache(&quot;C&quot;)
    call cache%operation()

    print *, &quot;List length: &quot;, size(factory%cache_list)

end program cache_main

!&gt; Results shall be:

!  A
!  A
!  B
!  C
!  List length:            3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç»„åˆæ¨¡å¼"><a class="header" href="#ç»„åˆæ¨¡å¼">ç»„åˆæ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/composite</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/composite/go/example</p>
<pre><code class="language-fortran">module composite_module

    implicit none
    private

    public :: file_t, folder_t

    type, abstract :: component_t
    contains
        procedure(component_t_search), deferred :: search
    end type component_t

    type, extends(component_t) :: file_t
        character(:), allocatable :: name
    contains
        procedure :: search =&gt; file_t_search
        procedure :: get_name =&gt; file_t_get_name
    end type file_t

    type node_t
        class(component_t), pointer :: node
    end type node_t

    type, extends(component_t) :: folder_t
        type(node_t), allocatable :: components(:)
        character(:), allocatable :: name
    contains
        procedure :: search =&gt; folder_t_search
    end type folder_t

    abstract interface
        subroutine component_t_search(self, keyward)
            import component_t
            class(component_t), intent(inout) :: self
            character(*), intent(in) :: keyward
        end subroutine component_t_search
    end interface

contains

    subroutine file_t_search(self, keyward)
        class(file_t), intent(inout) :: self
        character(*), intent(in) :: keyward
        print *, &quot;Searching for keyword &quot;, keyward, &quot; in file &quot;, self%name
    end subroutine file_t_search

    function file_t_get_name(self) result(name)
        class(file_t), intent(inout) :: self
        character(:), allocatable :: name
        name = self%name
    end function file_t_get_name

    ! - - - - - - - - - -

    subroutine folder_t_search(self, keyward)
        class(folder_t), intent(inout) :: self
        character(*), intent(in) :: keyward
        integer :: i
        print *, &quot;Searching recursively for keyword &quot;, keyward, &quot; in folder &quot;, self%name
        if (size(self%components) == 0) return
        do i = 1, size(self%components)
            call self%components(i)%node%search(keyward)
        end do
    end subroutine folder_t_search

end module composite_module
</code></pre>
<pre><code class="language-fortran">program composite_main
    use composite_module, only: file_t, folder_t
    implicit none
    type(file_t), target :: file1, file2, file3
    type(folder_t), target :: folder1
    type(folder_t) :: folder2

    file1%name = &quot;File1&quot;
    file2%name = &quot;File2&quot;
    file3%name = &quot;File3&quot;

    folder1%name = &quot;Folder1&quot;
    folder2%name = &quot;Folder2&quot;

    allocate (folder1%components(1))
    folder1%components(1)%node =&gt; file1

    allocate (folder2%components(3))
    folder2%components(1)%node =&gt; file2
    folder2%components(2)%node =&gt; file3
    folder2%components(3)%node =&gt; folder1

    call folder2%search(&quot;rose&quot;)

end program composite_main

!&gt; Results shall be:

!  Searching recursively for keyword rose in folder Folder2
!  Searching for keyword rose in file File2
!  Searching for keyword rose in file File3
!  Searching recursively for keyword rose in folder Folder1
!  Searching for keyword rose in file File1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¤–è§‚æ¨¡å¼"><a class="header" href="#å¤–è§‚æ¨¡å¼">å¤–è§‚æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/facade</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/facade/go/example</p>
<pre><code class="language-fortran">module facade_module

    implicit none
    private

    public :: new_wallet_facade, wallet_facade_t

    type account_t
        character(:), allocatable :: name
    contains
        procedure :: check_account =&gt; account_t_check_account
    end type account_t

    type security_code_t
        integer :: code
    contains
        procedure :: check_code =&gt; security_code_t_check_code
    end type security_code_t

    type wallet_t
        integer :: balance
    contains
        procedure :: credit_balance =&gt; wallet_t_credit_balance
        procedure :: debit_balance =&gt; wallet_t_debit_balance
    end type wallet_t

    type ledger_t
    contains
        procedure :: make_entry =&gt; ledger_t_make_entry
    end type ledger_t

    type notification_t
    contains
        procedure :: send_wallet_credit_notification =&gt; notification_t_send_wallet_credit_notification
        procedure :: send_wallet_debit_notification =&gt; notification_t_send_wallet_debit_notification
    end type notification_t

    type wallet_facade_t
        type(account_t) :: account
        type(wallet_t) :: wallet
        type(security_code_t) :: security_code
        type(notification_t) :: notification
        type(ledger_t) :: ledger
    contains
        procedure :: add_money_to_wallet =&gt; wallet_facade_t_add_money_to_wallet
        procedure :: deduct_money_from_wallet =&gt; wallet_facade_t_deduct_money_from_wallet
    end type wallet_facade_t

contains

    function new_wallet_facade(account_id, code) result(wallet_facade)
        character(*), intent(in) :: account_id
        integer, intent(in) :: code
        type(wallet_facade_t) :: wallet_facade
        print *, &quot;Starting create account&quot;
        wallet_facade = wallet_facade_t(account=account_t(account_id), &amp;
                                        security_code=security_code_t(code), &amp;
                                        wallet=wallet_t(balance=0), &amp;
                                        notification=notification_t(), &amp;
                                        ledger=ledger_t())
        print *, &quot;Account created&quot;
    end function new_wallet_facade

    subroutine wallet_facade_t_add_money_to_wallet(self, account_id, security_code, amount)
        class(wallet_facade_t), intent(inout) :: self
        character(*), intent(in) :: account_id
        integer, intent(in) :: security_code, amount
        print *, &quot;Starting add money to wallet&quot;
        call self%account%check_account(account_id)
        call self%security_code%check_code(security_code)
        call self%wallet%credit_balance(amount)
        call self%notification%send_wallet_credit_notification()
        call self%ledger%make_entry(account_id, &quot;credit&quot;, amount)
    end subroutine wallet_facade_t_add_money_to_wallet

    subroutine wallet_facade_t_deduct_money_from_wallet(self, account_id, security_code, amount)
        class(wallet_facade_t), intent(inout) :: self
        character(*), intent(in) :: account_id
        integer, intent(in) :: security_code, amount
        print *, &quot;Starting debit money from wallet&quot;
        call self%account%check_account(account_id)
        call self%security_code%check_code(security_code)
        call self%wallet%credit_balance(amount)
        call self%notification%send_wallet_credit_notification()
        call self%ledger%make_entry(account_id, &quot;credit&quot;, amount)
    end subroutine wallet_facade_t_deduct_money_from_wallet

    ! - - - - - - - - -

    subroutine account_t_check_account(self, account_name)
        class(account_t), intent(inout) :: self
        character(*), intent(in) :: account_name
        if (self%name /= account_name) then
            error stop &quot;Account Name is incorrect&quot;
        end if
        print *, &quot;Account Verified&quot;
    end subroutine account_t_check_account

    ! - - - - - - - - -

    subroutine security_code_t_check_code(self, incomming_code)
        class(security_code_t), intent(inout) :: self
        integer, intent(in) :: incomming_code
        if (self%code /= incomming_code) then
            error stop &quot;Security Code is incorrect&quot;
        end if
        print *, &quot;SecurityCode Verified&quot;
    end subroutine security_code_t_check_code

    ! - - - - - - - - -

    subroutine wallet_t_credit_balance(self, amount)
        class(wallet_t), intent(inout) :: self
        integer, intent(in) :: amount
        self%balance = self%balance + amount
        print *, &quot;Wallet balance added successfully&quot;
    end subroutine wallet_t_credit_balance

    subroutine wallet_t_debit_balance(self, amount)
        class(wallet_t), intent(inout) :: self
        integer, intent(in) :: amount
        if (self%balance &lt; amount) then
            error stop &quot;Balance is not sufficient&quot;
        end if
        print *, &quot;Wallet balance is Sufficient&quot;
        self%balance = self%balance - amount
    end subroutine wallet_t_debit_balance

    ! - - - - - - - - -

    subroutine ledger_t_make_entry(self, account_id, txn_type, amount)
        class(ledger_t), intent(inout) :: self
        character(*), intent(in) :: account_id, txn_type
        integer, intent(in) :: amount
        print *, &quot;Make ledger entry for accountId &quot;, account_id, &amp;
            &quot; with txnType &quot;, txn_type, &amp;
            &quot; for amount &quot;, amount
    end subroutine ledger_t_make_entry

    ! - - - - - - - - -

    subroutine notification_t_send_wallet_credit_notification(self)
        class(notification_t), intent(inout) :: self
        print *, &quot;Sending wallet credit notification&quot;
    end subroutine notification_t_send_wallet_credit_notification

    subroutine notification_t_send_wallet_debit_notification(self)
        class(notification_t), intent(inout) :: self
        print *, &quot;Sending wallet debit notification&quot;
    end subroutine notification_t_send_wallet_debit_notification

end module facade_module
</code></pre>
<pre><code class="language-fortran">program facade_main
    use facade_module, only: wallet_facade_t, new_wallet_facade
    implicit none
    type(wallet_facade_t) :: wallet_facade

    wallet_facade = new_wallet_facade(account_id=&quot;abc&quot;, code=1234)
    call wallet_facade%add_money_to_wallet(account_id=&quot;abc&quot;, security_code=1234, amount=10)
    call wallet_facade%deduct_money_from_wallet(account_id=&quot;abc&quot;, security_code=1234, amount=5)

end program facade_main

!&gt; Results shall be:

!  Starting create account
!  Account created
!  Starting add money to wallet
!  Account Verified
!  SecurityCode Verified
!  Wallet balance added successfully
!  Sending wallet credit notification
!  Make ledger entry for accountId abc with txnType credit for amount           10
!  Starting debit money from wallet
!  Account Verified
!  SecurityCode Verified
!  Wallet balance added successfully
!  Sending wallet credit notification
!  Make ledger entry for accountId abc with txnType credit for amount            5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä»£ç†æ¨¡å¼"><a class="header" href="#ä»£ç†æ¨¡å¼">ä»£ç†æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/proxy</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/proxy/go/example</p>
<pre><code class="language-fortran">module proxy_module

    use, intrinsic :: iso_fortran_env, only: int16
    implicit none
    private

    public :: nginx_t, new_nginx_server

    type, abstract :: server_t
    contains
        procedure(server_t_handle_request), deferred :: handle_request
    end type server_t

    abstract interface
        subroutine server_t_handle_request(self, url, method, code, msg)
            import server_t, int16
            class(server_t), intent(inout) :: self
            character(*), intent(in) :: url, method
            integer(int16), intent(out) :: code
            character(:), intent(out), allocatable :: msg
        end subroutine server_t_handle_request
    end interface

    type map_t
        character(:), allocatable :: url
        integer(int16) :: rate_limiter
    end type map_t

    type, extends(server_t) :: nginx_t
        type(application_t), allocatable :: application
        integer(int16) :: max_allowed_request
        type(map_t), allocatable :: map(:)
        ! TODO:
    contains
        procedure :: handle_request =&gt; nginx_t_handle_request
        procedure :: check_rate_limiting =&gt; nginx_t_check_rate_limiting
    end type nginx_t

    type, extends(server_t) :: application_t
    contains
        procedure :: handle_request =&gt; application_t_handle_request
    end type application_t

contains

    type(nginx_t) function new_nginx_server() result(nginx)
        type(map_t), allocatable :: map_(:)
        ! TODO:
        allocate (map_(2))
        map_(1) = map_t(url=&quot;/app/status&quot;, rate_limiter=0_int16)
        map_(2) = map_t(url=&quot;/create/user&quot;, rate_limiter=0_int16)

        nginx = nginx_t(application=application_t(), max_allowed_request=2, map=map_) ! TODO:
    end function new_nginx_server

    subroutine nginx_t_handle_request(self, url, method, code, msg)
        class(nginx_t), intent(inout) :: self
        character(*), intent(in) :: url, method
        integer(int16), intent(out) :: code
        character(:), intent(out), allocatable :: msg

        logical :: allowed

        allowed = self%check_rate_limiting(url)

        if (.not. allowed) then
            code = 403_int16
            msg = &quot;Not Allowed&quot;
            return
        end if

        call self%application%handle_request(url, method, code, msg)

    end subroutine nginx_t_handle_request

    logical function nginx_t_check_rate_limiting(self, url) result(allowed)
        class(nginx_t), intent(inout) :: self
        character(*), intent(in) :: url

        integer(int16) :: i

        do i = 1_int16, size(self%map, kind=int16)
            if (self%map(i)%url == url) exit
        end do

        ! i = i - 1_int16

        if (self%map(i)%rate_limiter == 0_int16) then
            self%map(i)%rate_limiter = 1_int16
        end if

        if (self%map(i)%rate_limiter &gt; self%max_allowed_request) then
            allowed = .false.
            return
        end if

        allowed = .true.
        self%map(i)%rate_limiter = self%map(i)%rate_limiter + 1_int16

    end function nginx_t_check_rate_limiting

    subroutine application_t_handle_request(self, url, method, code, msg)
        class(application_t), intent(inout) :: self
        character(*), intent(in) :: url, method
        integer(int16), intent(out) :: code
        character(:), intent(out), allocatable :: msg

        if (url == &quot;/app/status&quot; .and. method == &quot;GET&quot;) then
            code = 200_int16
            msg = &quot;Ok&quot;
            return
        end if

        if (url == &quot;/create/user&quot; .and. method == &quot;POST&quot;) then
            code = 201_int16
            msg = &quot;User Created&quot;
            return
        end if

        code = 404_int16
        msg = &quot;Not Ok&quot;

    end subroutine application_t_handle_request

end module proxy_module
</code></pre>
<pre><code class="language-fortran">program proxy_main

    use, intrinsic :: iso_fortran_env, only: int16
    use proxy_module, only: nginx_t, new_nginx_server

    type(nginx_t) :: nginx_server
    character(*), parameter :: app_status_url = &quot;/app/status&quot;, create_user_url = &quot;/create/user&quot;
    integer(int16) :: code
    character(:), allocatable :: body

    nginx_server = new_nginx_server()

    call nginx_server%handle_request(app_status_url, &quot;GET&quot;, code, body)
    print *, &quot;Url: &quot;, app_status_url, new_line(&quot;&quot;), &amp;
        &quot;Http code: &quot;, code, new_line(&quot;&quot;), &amp;
        &quot;Body: &quot;, body

    call nginx_server%handle_request(app_status_url, &quot;GET&quot;, code, body)
    print *, &quot;Url: &quot;, app_status_url, new_line(&quot;&quot;), &amp;
        &quot;Http code: &quot;, code, new_line(&quot;&quot;), &amp;
        &quot;Body: &quot;, body

    call nginx_server%handle_request(app_status_url, &quot;GET&quot;, code, body)
    print *, &quot;Url: &quot;, app_status_url, new_line(&quot;&quot;), &amp;
        &quot;Http code: &quot;, code, new_line(&quot;&quot;), &amp;
        &quot;Body: &quot;, body

    call nginx_server%handle_request(create_user_url, &quot;POST&quot;, code, body)
    print *, &quot;Url: &quot;, create_user_url, new_line(&quot;&quot;), &amp;
        &quot;Http code: &quot;, code, new_line(&quot;&quot;), &amp;
        &quot;Body: &quot;, body

    call nginx_server%handle_request(create_user_url, &quot;GET&quot;, code, body)
    print *, &quot;Url: &quot;, create_user_url, new_line(&quot;&quot;), &amp;
        &quot;Http code: &quot;, code, new_line(&quot;&quot;), &amp;
        &quot;Body: &quot;, body

end program proxy_main

!&gt; Results shall be:

!  Url: /app/status
!  Http code:     200
!  Body: Ok
!  Url: /app/status
!  Http code:     200
!  Body: Ok
!  Url: /app/status
!  Http code:     403
!  Body: Not Allowed
!  Url: /create/user
!  Http code:     201
!  Body: User Created
!  Url: /create/user
!  Http code:     404
!  Body: Not Ok
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è£…é¥°æ¨¡å¼"><a class="header" href="#è£…é¥°æ¨¡å¼">è£…é¥°æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/decorator</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/decorator/go/example</p>
<pre><code class="language-fortran">module wrapper_module

    implicit none
    private

    public :: vegge_mania_t, tomato_topping_t, cheese_topping_t

    type, abstract :: pizza_t
    contains
        procedure(pizza_t_get_price), deferred :: get_price
    end type pizza_t

    abstract interface
        function pizza_t_get_price(self) result(price)
            import :: pizza_t
            class(pizza_t), intent(inout) :: self
            integer :: price
        end function pizza_t_get_price
    end interface

    type, extends(pizza_t) :: vegge_mania_t
    contains
        procedure :: get_price =&gt; vegge_mania_t_get_price
    end type vegge_mania_t

    type, extends(pizza_t) :: tomato_topping_t
        class(pizza_t), pointer :: pizza
    contains
        procedure :: get_price =&gt; tomato_topping_t_get_price
    end type tomato_topping_t

    type, extends(pizza_t) :: cheese_topping_t
        class(pizza_t), pointer :: pizza
    contains
        procedure :: get_price =&gt; cheese_topping_t_get_price
    end type cheese_topping_t

contains

    function vegge_mania_t_get_price(self) result(price)
        class(vegge_mania_t), intent(inout) :: self
        integer :: price
        price = 15
    end function vegge_mania_t_get_price

    function tomato_topping_t_get_price(self) result(price)
        class(tomato_topping_t), intent(inout) :: self
        integer :: price
        price = self%pizza%get_price() + 7
    end function tomato_topping_t_get_price

    function cheese_topping_t_get_price(self) result(price)
        class(cheese_topping_t), intent(inout) :: self
        integer :: price
        price = self%pizza%get_price() + 10
    end function cheese_topping_t_get_price

end module wrapper_module
</code></pre>
<pre><code class="language-fortran">program wrapper_main

    use wrapper_module, only: vegge_mania_t, cheese_topping_t, tomato_topping_t
    implicit none
    type(vegge_mania_t), target :: pizza
    type(cheese_topping_t), target :: pizza_with_cheese
    type(tomato_topping_t) :: pizza_with_tomato_and_cheese

    pizza_with_cheese%pizza =&gt; pizza
    pizza_with_tomato_and_cheese%pizza =&gt; pizza_with_cheese

    print *, &quot;Prince of veggeMania with tomato and cheese topping is &quot;, pizza_with_tomato_and_cheese%get_price()

end program wrapper_main

!&gt; Results shall be:

! Prince of veggeMania with tomato and cheese topping is           32.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è´£ä»»é“¾æ¨¡å¼"><a class="header" href="#è´£ä»»é“¾æ¨¡å¼">è´£ä»»é“¾æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/chain-of-responsibility</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example</p>
<h2 id="ç¤ºä¾‹"><a class="header" href="#ç¤ºä¾‹">ç¤ºä¾‹</a></h2>
<p>æœ¬ä¾‹å­æ¨¡æ‹ŸåŒ»é™¢çš„çœ‹ç—…ç¼´è´¹çš„è´£ä»»é“¾ã€‚</p>
<p>ç—…äººéœ€è¦è¿›è¡Œçš„å¤§è‡´æ­¥éª¤æ˜¯ï¼š</p>
<ol>
<li>è¿›é™¢ï¼Œæ³¨å†Œä¿¡æ¯</li>
<li>åŒ»ç”Ÿæ£€æŸ¥</li>
<li>è¯æˆ¿ç»™è¯</li>
<li>ç—…äººç¼´è´¹ï¼Œå‡ºé™¢</li>
</ol>
<pre><code class="language-fortran">!&gt; CoR: Hospital departments
module hospital_CoR

    implicit none
    private

    public :: patient, department, reception, doctor, medical, cashier

    type patient
        character(:), allocatable :: name
        logical :: registration_done
        logical :: doctor_check_up_done
        logical :: medicine_done
        logical :: payment_done
    end type patient

    type, abstract :: department
    contains
        procedure(execute_procedure), deferred :: execute
        procedure(set_next_procedure), deferred :: set_next
    end type department

    abstract interface
        subroutine execute_procedure(self, p)
            import department, patient
            class(department), intent(inout) :: self
            type(patient), intent(inout) :: p
        end subroutine execute_procedure
        subroutine set_next_procedure(self, next)
            import department
            class(department), intent(inout) :: self
            class(department), intent(inout) :: next
        end subroutine set_next_procedure
    end interface

    type, extends(department) :: reception
        class(department), pointer :: next
    contains
        procedure :: execute =&gt; reception_execute
        procedure :: set_next =&gt; reception_set_next
    end type reception

    type, extends(department) :: doctor
        class(department), pointer :: next
    contains
        procedure :: execute =&gt; doctor_execute
        procedure :: set_next =&gt; doctor_set_next
    end type doctor

    type, extends(department) :: medical
        class(department), pointer :: next
    contains
        procedure :: execute =&gt; medicine_execute
        procedure :: set_next =&gt; medicine_set_next
    end type medical

    type, extends(department) :: cashier
        class(department), pointer :: next
    contains
        procedure :: execute =&gt; cashier_execute
        procedure :: set_next =&gt; cashier_set_next
    end type cashier

contains

    subroutine reception_execute(self, p)
        class(reception), intent(inout) :: self
        type(patient), intent(inout) :: p

        if (p%registration_done) then
            print *, &quot;Patient registration already done.âœ”ï¸&quot;
            call self%next%execute(p)
            return
        end if

        print *, &quot;Reception registering patient.&quot;
        p%registration_done = .true.
        call self%next%execute(p)

    end subroutine reception_execute

    subroutine reception_set_next(self, next)
        class(reception), intent(inout) :: self
        class(department), intent(inout) :: next

        allocate (self%next, source=next)

    end subroutine reception_set_next

    subroutine doctor_execute(self, p)
        class(doctor), intent(inout) :: self
        type(patient), intent(inout) :: p

        if (p%doctor_check_up_done) then
            print *, &quot;Doctor checkup already done.âœ”ï¸&quot;
            call self%next%execute(p)
            return
        end if

        print *, &quot;Doctor checking patient.&quot;
        p%doctor_check_up_done = .true.
        call self%next%execute(p)

    end subroutine doctor_execute

    subroutine doctor_set_next(self, next)
        class(doctor), intent(inout) :: self
        class(department), intent(inout) :: next

        allocate (self%next, source=next)

    end subroutine doctor_set_next

    subroutine medicine_execute(self, p)
        class(medical), intent(inout) :: self
        type(patient), intent(inout) :: p

        if (p%medicine_done) then
            print *, &quot;Medicine already given to patient.âœ”ï¸&quot;
            call self%next%execute(p)
            return
        end if

        print *, &quot;Medical giving medicine to patient.&quot;
        p%medicine_done = .true.
        call self%next%execute(p)

    end subroutine medicine_execute

    subroutine medicine_set_next(self, next)
        class(medical), intent(inout) :: self
        class(department), intent(inout) :: next

        allocate (self%next, source=next)

    end subroutine medicine_set_next

    subroutine cashier_execute(self, p)
        class(cashier), intent(inout) :: self
        type(patient), intent(inout) :: p

        if (p%payment_done) then
            print *, &quot;Payment Done.âœ”ï¸&quot;
            return
        end if

        print *, &quot;Cashier getting money from patient.&quot;
        p%payment_done = .true.

    end subroutine cashier_execute

    subroutine cashier_set_next(self, next)
        class(cashier), intent(inout) :: self
        class(department), intent(inout) :: next

        allocate (self%next, source=next)

    end subroutine cashier_set_next

end module hospital_CoR
</code></pre>
<pre><code class="language-fortran">
!&gt; CoR: Patient visiting hospital
program CoR_main

    use hospital_CoR

    type(cashier) :: c
    type(medical) :: m
    type(doctor) :: d
    type(reception) :: r

    type(patient) :: p1, p2

    !&gt; Set next for departments
    call m%set_next(c)
    call d%set_next(m)
    call r%set_next(d)

    p1 = patient(&quot;abc&quot;, .true., .true., .true., .true.)
    !&gt; Patient visiting
    print *, &quot;&gt; Patient `&quot;//p1%name//&quot;` : &quot;
    call r%execute(p1)

    p2 = patient(&quot;def&quot;, .true., .false., .false., .false.)
    !&gt; Patient visiting
    print *, &quot;&gt; Patient `&quot;//p2%name//&quot;` : &quot;
    call r%execute(p2)

    !&gt; Optional statements
    deallocate (m%next)
    deallocate (d%next)
    deallocate (r%next)

end program CoR_main

!&gt; Results shall be:

!  &gt; Patient `abc` :
!  Patient registration already done.âœ”ï¸
!  Doctor checkup already done.âœ”ï¸
!  Medicine already given to patient.âœ”ï¸
!  Payment Done.âœ”ï¸
!  &gt; Patient `def` :
!  Patient registration already done.âœ”ï¸
!  Doctor checking patient.
!  Medical giving medicine to patient.
!  Cashier getting money from patient.
</code></pre>
<h2 id="è¯„ä»·"><a class="header" href="#è¯„ä»·">è¯„ä»·</a></h2>
<p>è´£ä»»é“¾å¾ˆåƒæµæ°´çº¿ï¼Œä¸Šä¸€èŠ‚ç‚¹å¤„ç†å®Œè¿›å…¥ä¸‹ä¸€èŠ‚ç‚¹ã€‚</p>
<p>å¯ä»¥åº”ç”¨äºç§‘å­¦è®¡ç®—çš„æ–‡ä»¶è¾“å…¥æ£€æŸ¥è¿‡ç¨‹ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å‘½ä»¤æ¨¡å¼"><a class="header" href="#å‘½ä»¤æ¨¡å¼">å‘½ä»¤æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/command</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/command/go/example</p>
<pre><code class="language-fortran">!&gt; Reference: https://refactoring.guru/design-patterns/command/go/example
module command_pattern

    implicit none
    private

    public :: tv, on_command, off_command, button

    !&gt; Abstract classes

    type, abstract :: command
    contains
        procedure(execute_procedure), deferred :: execute
    end type command

    type, abstract :: device
    contains
        procedure(on_procedure), deferred :: on
        procedure(off_procedure), deferred :: off
    end type device

    abstract interface
        subroutine execute_procedure(self)
            import command
            class(command), intent(inout) :: self
        end subroutine execute_procedure
        subroutine on_procedure(self)
            import device
            class(device), intent(inout) :: self
        end subroutine on_procedure
        subroutine off_procedure(self)
            import device
            class(device), intent(inout) :: self
        end subroutine off_procedure
    end interface

    !&gt; Specific Objects

    type, extends(command) :: on_command
        class(device), pointer :: d
    contains
        procedure :: execute =&gt; on_command_execute
    end type on_command

    type, extends(command) :: off_command
        class(device), pointer :: d
    contains
        procedure :: execute =&gt; off_command_execute
    end type off_command

    type, extends(device) :: tv
        logical :: is_running
    contains
        procedure :: on =&gt; tv_on
        procedure :: off =&gt; tv_off
    end type tv

    type :: button
        class(command), pointer :: c
    contains
        procedure :: press
    end type button

contains

    subroutine press(self)
        class(button), intent(inout) :: self
        call self%c%execute()
    end subroutine press

    subroutine on_command_execute(self)
        class(on_command), intent(inout) :: self
        call self%d%on()
    end subroutine on_command_execute

    subroutine off_command_execute(self)
        class(off_command), intent(inout) :: self
        call self%d%off()
    end subroutine off_command_execute

    subroutine tv_on(self)
        class(tv), intent(inout) :: self
        self%is_running = .true.
        print *, &quot;Turning tv on. âœ”ï¸&quot;
    end subroutine tv_on

    subroutine tv_off(self)
        class(tv), intent(inout) :: self
        self%is_running = .false.
        print *, &quot;Turning tv off. âŒ&quot;
    end subroutine tv_off

end module command_pattern
</code></pre>
<pre><code class="language-fortran">!&gt; Reference: https://refactoring.guru/design-patterns/command/go/example
program test_command

    use command_pattern, only: tv, on_command, off_command, button
    type(tv) :: t
    type(on_command) :: on_c
    type(off_command) :: off_c

    type(button) :: on_b
    type(button) :: off_b

    !&gt; Linking
    allocate (on_c%d, source=t)
    allocate (off_c%d, source=t)

    allocate (on_b%c, source=on_c)
    allocate (off_b%c, source=off_c)

    !&gt; Operating
    call on_b%press()
    call off_b%press()

    !&gt; Free memory.
    deallocate (on_c%d)
    deallocate (off_c%d)
    deallocate (on_b%c)
    deallocate (off_b%c)

end program test_command

!&gt; Results shall be:

!  Turning tv on. âœ”ï¸
!  Turning tv off. âŒ
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¿­ä»£å™¨æ¨¡å¼"><a class="header" href="#è¿­ä»£å™¨æ¨¡å¼">è¿­ä»£å™¨æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/iterator</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/iterator/go/example</p>
<pre><code class="language-fortran">module iterator_module

    use, intrinsic :: iso_fortran_env, only: int8
    implicit none
    private

    public :: user_t, user_collection_t, user_iterator_t, iterator_t

    !&gt; Abstract types

    !&gt; Collection
    type, abstract :: collection_t
    contains
        procedure(collection_t_create_iterator), deferred :: create_iterator
    end type collection_t

    !&gt; Iterator
    type, abstract :: iterator_t
    contains
        procedure(iterator_t_has_next), deferred :: has_next
        procedure(iterator_t_get_next), deferred :: get_next
    end type iterator_t

    !&gt; User
    type user_t
        character(:), allocatable :: name
        integer(int8) :: age
    end type user_t

    abstract interface

        function collection_t_create_iterator(self) result(iterator)
            import iterator_t, collection_t
            !&gt; TODO:
            class(collection_t), intent(in) :: self
            class(iterator_t), allocatable :: iterator
        end function collection_t_create_iterator

        logical function iterator_t_has_next(self)
            import iterator_t
            class(iterator_t), intent(in) :: self
        end function iterator_t_has_next

        type(user_t) function iterator_t_get_next(self)
            import user_t, iterator_t
            class(iterator_t), intent(inout) :: self
        end function iterator_t_get_next

    end interface

    !&gt; Specific types

    !&gt; User collection
    type, extends(collection_t) :: user_collection_t
        type(user_t), allocatable :: users(:)
    contains
        procedure :: create_iterator =&gt; user_collection_t_create_iterator
    end type user_collection_t

    !&gt; User iterator
    type, extends(iterator_t) :: user_iterator_t
        integer :: index
        type(user_t), allocatable :: users(:)
    contains
        procedure :: has_next =&gt; user_iterator_t_has_next
        procedure :: get_next =&gt; user_iterator_t_get_next
    end type user_iterator_t

contains

    function user_collection_t_create_iterator(self) result(iterator)
        class(user_collection_t), intent(in) :: self
        class(iterator_t), allocatable :: iterator
        ! TODO:
        iterator = user_iterator_t(index=0, users=self%users)
    end function user_collection_t_create_iterator

    logical function user_iterator_t_has_next(self) result(has)
        class(user_iterator_t), intent(in) :: self

        has = merge(.true., .false., self%index &lt; size(self%users))

    end function user_iterator_t_has_next

    type(user_t) function user_iterator_t_get_next(self) result(user)
        class(user_iterator_t), intent(inout) :: self

        self%index = self%index + 1
        user = self%users(self%index)

    end function user_iterator_t_get_next

end module iterator_module
</code></pre>
<pre><code class="language-fortran">program iterator_main

    use, intrinsic :: iso_fortran_env, only: int8
    use iterator_module, only: user_t, user_collection_t, user_iterator_t, iterator_t

    type(user_t) :: user1, user2, user
    type(user_collection_t) :: user_collection
    ! TODO:
    class(iterator_t), allocatable :: iterator

    user1 = user_t(name=&quot;A&quot;, age=30_int8)
    user2 = user_t(name=&quot;B&quot;, age=20_int8)

    user_collection = user_collection_t(users=[user1, user2])

    !&gt; Specific iterator
    allocate (user_iterator_t :: iterator)
    iterator = user_collection%create_iterator()

    do while (iterator%has_next())
        user = iterator%get_next()
        print &quot;(3A,I3)&quot;, &quot;User is &quot;, user%name, &quot;, age is &quot;, user%age
    end do

    deallocate (iterator)

end program iterator_main

!&gt; Results shall be:

!  User is A, age is  30
!  User is B, age is  20
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è§‚å¯Ÿè€…æ¨¡å¼"><a class="header" href="#è§‚å¯Ÿè€…æ¨¡å¼">è§‚å¯Ÿè€…æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/observer</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/observer/go/example</p>
<pre><code class="language-fortran">!&gt; Reference: https://refactoring.guru/design-patterns/observer/go/example
module observer_pattern

    implicit none
    private

    public :: item, customer, new_item

    !&gt; Abstract classes
    type, abstract :: subject
    contains
        procedure(register_procedure), deferred :: register
        procedure(deregister_procedure), deferred :: deregister
        procedure(notify_all_procedure), deferred :: notify_all
    end type subject

    type, abstract :: observer
    contains
        procedure(update_procedure), deferred :: update
        procedure(get_ID_procedure), deferred :: get_ID
    end type observer

    !&gt; We cannot directly use `class(observer), allocatable :: o_list(:)`
    !&gt;  instead of `type(node), allocatable :: o_list(:)`.
    type node
        class(observer), allocatable :: o
    end type node

    abstract interface
        subroutine register_procedure(self, o)
            import subject, observer
            class(subject), intent(inout) :: self
            class(observer), intent(inout) :: o
        end subroutine register_procedure
        subroutine deregister_procedure(self, o)
            import subject, observer
            class(subject), intent(inout) :: self
            class(observer), intent(inout) :: o
        end subroutine deregister_procedure
        subroutine notify_all_procedure(self)
            import subject
            class(subject), intent(inout) :: self
        end subroutine notify_all_procedure
        subroutine update_procedure(self, s)
            import observer
            class(observer), intent(inout) :: self
            character(len=*), intent(inout) :: s
        end subroutine update_procedure
        function get_ID_procedure(self) result(result)
            import observer
            class(observer), intent(inout) :: self
            character(len=:), allocatable :: result
        end function get_ID_procedure
    end interface

    !&gt; Specific objects

    type, extends(subject) :: item
        type(node), allocatable :: o_list(:)
        character(len=:), allocatable :: name
        logical :: in_stock
    contains
        procedure :: update_availability
        procedure :: register
        procedure :: deregister
        procedure :: notify_all
    end type item

    type, extends(observer) :: customer
        character(len=:), allocatable :: ID
    contains
        procedure :: update
        procedure :: get_ID
    end type customer

contains

    !&gt; Constructor of `item`.
    function new_item(name) result(i)
        character(*), intent(in) :: name
        type(item) :: i
        i%name = name
    end function new_item

    !&gt; Remove a object from the subscription array.
    function remove_from_slice(o_list, o_to_remove) result(result)
        type(node), intent(inout) :: o_list(:)
        class(observer), intent(inout) :: o_to_remove
        type(node), allocatable :: result(:)
        character(len=:), allocatable :: id
        integer :: i, j
        i = size(o_list)
        id = o_to_remove%get_ID()
        do j = 1, i
            if (o_list(j)%o%get_ID() == id) then
                allocate (result(i - 1), source=[o_list(:j - 1), o_list(j + 1:)])
                return
            end if
        end do
        result = o_list
    end function remove_from_slice

    !&gt; Append a object to the subscription array.
    function append_slice(o_list, o_to_append) result(result)
        type(node), intent(inout), allocatable :: o_list(:)
        class(observer), intent(inout) :: o_to_append
        type(node), allocatable :: result(:)
        integer :: i
        if (.not. allocated(o_list)) then
            allocate (result(1))
            allocate (result(1)%o, source=o_to_append)
        else
            i = size(o_list)
            allocate (result(i + 1))
            result(1:i) = o_list
            allocate (result(i + 1)%o, source=o_to_append)
        end if
    end function append_slice

    subroutine update_availability(self)
        class(item), intent(inout) :: self
        print *, &quot;&gt; Item &quot;//self%name//&quot; ğŸ‘” is now in stock.&quot;
        self%in_stock = .true.
        call self%notify_all()
    end subroutine update_availability

    subroutine register(self, o)
        class(item), intent(inout) :: self
        class(observer), intent(inout) :: o
        self%o_list = append_slice(self%o_list, o)
    end subroutine register

    subroutine deregister(self, o)
        class(item), intent(inout) :: self
        class(observer), intent(inout) :: o
        self%o_list = remove_from_slice(self%o_list, o)
    end subroutine deregister

    subroutine notify_all(self)
        class(item), intent(inout) :: self
        integer :: i
        do i = 1, size(self%o_list)
            call self%o_list(i)%o%update(self%name)
        end do
    end subroutine notify_all

    subroutine update(self, s)
        class(customer), intent(inout) :: self
        character(len=*), intent(inout) :: s
        print *, &quot;Sending email to customer &quot;//self%ID//&quot; ğŸ“¨ for item &quot;//s//&quot;.&quot;
    end subroutine update

    function get_ID(self) result(result)
        class(customer), intent(inout) :: self
        character(len=:), allocatable :: result
        result = self%ID
    end function get_ID

end module observer_pattern
</code></pre>
<pre><code class="language-fortran">!&gt; Reference: https://refactoring.guru/design-patterns/observer/go/example
program test_observer

    use observer_pattern, only: item, customer, new_item
    type(item) :: shirt_item
    type(customer) :: observer_first, observer_second, observer_third

    !&gt; A shirt item
    shirt_item = new_item(&quot;A Shirt&quot;)

    !&gt; Some customers
    observer_first = customer(ID=&quot;abc@gmail.com&quot;)
    observer_second = customer(ID=&quot;def@gmail.com&quot;)
    observer_third = customer(ID=&quot;xyz@foxmail.com&quot;)

    !&gt; Scene 1
    call shirt_item%register(observer_first)
    call shirt_item%register(observer_second)
    call shirt_item%update_availability()

    !&gt; Scene 2
    call shirt_item%deregister(observer_first)
    call shirt_item%register(observer_third)
    call shirt_item%update_availability()

end program test_observer

!&gt; Results shall be:

!  &gt; Item A Shirt ğŸ‘” is now in stock.
!  Sending email to customer abc@gmail.com ğŸ“¨ for item A Shirt.
!  Sending email to customer def@gmail.com ğŸ“¨ for item A Shirt.
!  &gt; Item A Shirt ğŸ‘” is now in stock.
!  Sending email to customer def@gmail.com ğŸ“¨ for item A Shirt.
!  Sending email to customer xyz@foxmail.com ğŸ“¨ for item A Shirt.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä¸­ä»‹è€…æ¨¡å¼"><a class="header" href="#ä¸­ä»‹è€…æ¨¡å¼">ä¸­ä»‹è€…æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/mediator</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/mediator/go/example</p>
<pre><code class="language-fortran">module mediator_module

    implicit none
    private

    public :: station_manager_t, passenger_train_t, freight_train_t

    type, abstract :: train_t
    contains
        procedure(train_t_arrive), deferred :: arrive
        procedure(train_t_depart), deferred :: depart
        procedure(train_t_permit_arrival), deferred :: permit_arrival
    end type train_t

    type, abstract :: mediator_t
    contains
        procedure(mediator_t_can_arrive), deferred :: can_arrive
        procedure(mediator_t_notify_about_departure), deferred :: notify_about_departure
    end type mediator_t

    abstract interface

        subroutine train_t_arrive(self)
            import train_t
            class(train_t), intent(inout) :: self
        end subroutine train_t_arrive

        subroutine train_t_depart(self)
            import train_t
            class(train_t), intent(inout) :: self
        end subroutine train_t_depart

        subroutine train_t_permit_arrival(self)
            import train_t
            class(train_t), intent(inout) :: self
        end subroutine train_t_permit_arrival

        logical function mediator_t_can_arrive(self, train) result(can)
            import mediator_t, train_t
            class(mediator_t), intent(inout) :: self
            class(train_t), intent(in), target :: train
        end function mediator_t_can_arrive

        subroutine mediator_t_notify_about_departure(self)
            import mediator_t
            class(mediator_t), intent(inout) :: self
        end subroutine mediator_t_notify_about_departure

    end interface

    type, extends(train_t) :: passenger_train_t
        class(mediator_t), pointer :: mediator
    contains
        procedure :: arrive =&gt; passenger_train_t_arrive
        procedure :: depart =&gt; passenger_train_t_depart
        procedure :: permit_arrival =&gt; passenger_train_t_permit_arrival
    end type passenger_train_t

    type, extends(train_t) :: freight_train_t
        class(mediator_t), pointer :: mediator
    contains
        procedure :: arrive =&gt; freight_train_t_arrive
        procedure :: depart =&gt; freight_train_t_depart
        procedure :: permit_arrival =&gt; freight_train_t_permit_arrival
    end type freight_train_t

    type node_t
        class(train_t), pointer :: train
    end type node_t

    type, extends(mediator_t) :: station_manager_t
        logical :: is_platform_free = .true.
        type(node_t), allocatable :: list(:)
    contains
        procedure :: can_arrive =&gt; station_manager_t_can_arrive
        procedure :: notify_about_departure =&gt; station_manager_t_notify_about_departure
    end type station_manager_t

contains

    subroutine passenger_train_t_arrive(self)
        class(passenger_train_t), intent(inout) :: self
        if (.not. self%mediator%can_arrive(self)) then
            print *, &quot;Passenger train: arrival blocked, waiting&quot;
            return
        end if
        print *, &quot;Passenger train: arrived&quot;
    end subroutine passenger_train_t_arrive

    subroutine passenger_train_t_depart(self)
        class(passenger_train_t), intent(inout) :: self
        print *, &quot;Passenger train: leaving&quot;
        call self%mediator%notify_about_departure()
    end subroutine passenger_train_t_depart

    subroutine passenger_train_t_permit_arrival(self)
        class(passenger_train_t), intent(inout) :: self
        print *, &quot;Passenger train: arrival permitted, arriving&quot;
        call self%arrive()
    end subroutine passenger_train_t_permit_arrival

    subroutine freight_train_t_arrive(self)
        class(freight_train_t), intent(inout) :: self
        
        if (.not. self%mediator%can_arrive(self)) then
            print *, &quot;Freight train: arrival blocked, waiting&quot;
            return
        end if
        print *, &quot;Freight train: arrived&quot;
        
    end subroutine freight_train_t_arrive

    subroutine freight_train_t_depart(self)
        class(freight_train_t), intent(inout) :: self
        print *, &quot;freight train: leaving&quot;
        call self%mediator%notify_about_departure()
    end subroutine freight_train_t_depart

    subroutine freight_train_t_permit_arrival(self)
        class(freight_train_t), intent(inout) :: self
        print *, &quot;Freight train: arrival permitted, arriving&quot;
        call self%arrive()
    end subroutine freight_train_t_permit_arrival

    logical function station_manager_t_can_arrive(self, train) result(can)
        class(station_manager_t), intent(inout) :: self
        class(train_t), intent(in), target :: train
        
        if (self%is_platform_free) then
            self%is_platform_free = .false.
            can = .true.
            return
        end if
        self%list = [self%list, node_t(train)]
        can = .false.
        
    end function station_manager_t_can_arrive

    subroutine station_manager_t_notify_about_departure(self)
        class(station_manager_t), intent(inout) :: self
        class(train_t), pointer :: train
        
        if (.not. self%is_platform_free) then
            self%is_platform_free = .true.
        end if
        if (size(self%list) &gt; 0) then
            train =&gt; self%list(1)%train
            !&gt; å†…å­˜æ³„éœ²
            self%list = self%list(2:)
            call train%permit_arrival()
        end if
        
    end subroutine station_manager_t_notify_about_departure

end module mediator_module
</code></pre>
<pre><code class="language-fortran">program mediator_main

    use mediator_module, only: station_manager_t,passenger_train_t,freight_train_t
    implicit none
    type(station_manager_t), target :: station_manager
    type(passenger_train_t) :: passenger_train
    type(freight_train_t) :: freight_train
    
    allocate(station_manager%list(0))
    passenger_train%mediator =&gt; station_manager
    freight_train%mediator =&gt; station_manager
    
    call passenger_train%arrive()
    call freight_train%arrive()
    call passenger_train%depart()
    
end program mediator_main

!&gt; Results shall be:

!  Passenger train: arrived
!  Freight train: arrival blocked, waiting
!  Passenger train: leaving
!  Freight train: arrival permitted, arriving
!  Freight train: arrived
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="å¤‡å¿˜å½•æ¨¡å¼"><a class="header" href="#å¤‡å¿˜å½•æ¨¡å¼">å¤‡å¿˜å½•æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/memento</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/memento/go/example</p>
<pre><code class="language-fortran">module memento_module

    implicit none
    private

    public :: caretaker_t, originator_t

    type originator_t
        character(:), allocatable :: state
    contains
        procedure :: create_memento =&gt; originator_t_create_memento
        procedure :: restore_memento =&gt; originator_t_restore_memento
        procedure :: set_state =&gt; originator_t_set_state
        procedure :: get_state =&gt; originator_t_get_state
    end type originator_t

    type memento_t
        character(:), allocatable :: state
    end type memento_t

    type caretaker_t
        type(memento_t), allocatable :: memento(:)
    contains
        procedure :: add_memento =&gt; caretaker_t_add_memento
        procedure :: get_memento =&gt; caretaker_t_get_memento
    end type caretaker_t

contains

    function originator_t_create_memento(self) result(memento)
        class(originator_t), intent(inout) :: self
        type(memento_t) :: memento
        memento%state = self%state
    end function originator_t_create_memento

    subroutine originator_t_restore_memento(self, memento)
        class(originator_t), intent(inout) :: self
        type(memento_t), intent(in) :: memento
        self%state = memento%state
    end subroutine originator_t_restore_memento

    subroutine originator_t_set_state(self, state)
        class(originator_t), intent(inout) :: self
        character(*), intent(in) :: state
        self%state = state
    end subroutine originator_t_set_state

    function originator_t_get_state(self) result(state)
        class(originator_t), intent(inout) :: self
        character(:), allocatable :: state
        state = self%state
    end function originator_t_get_state

    subroutine caretaker_t_add_memento(self, memento)
        class(caretaker_t), intent(inout) :: self
        type(memento_t), intent(in) :: memento
        self%memento = [self%memento, memento]
    end subroutine caretaker_t_add_memento

    function caretaker_t_get_memento(self, index) result(memento)
        class(caretaker_t), intent(inout) :: self
        integer, intent(in) :: index
        type(memento_t) :: memento
        memento = self%memento(index)
    end function caretaker_t_get_memento

end module memento_module
</code></pre>
<pre><code class="language-fortran">program memento_main

    use memento_module, only: caretaker_t, originator_t

    type(caretaker_t) :: caretaker
    type(originator_t) :: originator

    allocate (caretaker%memento(0))
    originator%state = &quot;A&quot;

    print *, &quot;Originator state: &quot;, originator%get_state()
    call caretaker%add_memento(originator%create_memento())

    call originator%set_state(&quot;B&quot;)
    print *, &quot;Originator current state: &quot;, originator%get_state()
    call caretaker%add_memento(originator%create_memento())

    call originator%set_state(&quot;C&quot;)
    print *, &quot;Originator current state: &quot;, originator%get_state()
    call caretaker%add_memento(originator%create_memento())

    call originator%restore_memento(caretaker%get_memento(2))
    print *, &quot;Restored to state: &quot;, originator%get_state()

    call originator%restore_memento(caretaker%get_memento(1))
    print *, &quot;Restored to state: &quot;, originator%get_state()

end program memento_main

!&gt; Results shall be:

!  Originator state: A
!  Originator current state: B
!  Originator current state: C
!  Restored to state: B
!  Restored to state: A
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="çŠ¶æ€æ¨¡å¼"><a class="header" href="#çŠ¶æ€æ¨¡å¼">çŠ¶æ€æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/state</p>
<p>Fortranä»£ç ï¼šhttps://my.oschina.net/zuozhihua/blog/5150176</p>
<pre><code class="language-fortran">module state_module

    implicit none
    private

    public :: person_t

    type :: hungry_state_t
        logical :: state
    contains
        procedure :: hungry =&gt; hungry_state_t_hungry
        procedure :: no_hungry =&gt; hungry_state_t_no_hungry
    end type hungry_state_t

    type :: person_t
        type(hungry_state_t) :: hungry_state
    contains
        procedure :: eat =&gt; person_t_eat
        procedure :: work =&gt; person_t_work
    end type

contains

    subroutine person_t_eat(self)
        class(person_t), intent(inout) :: self
        if (self%hungry_state%state) then
            print *, &quot;Eatting..&quot;
            !!// æ”¹å˜çŠ¶æ€
            call self%hungry_state%no_hungry
        else
            print *, &quot;Already baole!!&quot;
        end if
    end subroutine person_t_eat

    subroutine person_t_work(self)
        class(person_t), intent(inout) :: self
        if (self%hungry_state%state) then
            print *, &quot;I am hungry, no work!!&quot;
        else
            print *, &quot;Ok, let us do work..&quot;
            call self%hungry_state%hungry
        end if
    end subroutine person_t_work

    subroutine hungry_state_t_hungry(self)
        class(hungry_state_t), intent(inout) :: self
        self%state = .true.
    end subroutine hungry_state_t_hungry

    subroutine hungry_state_t_no_hungry(self)
        class(hungry_state_t), intent(inout) :: self
        self%state = .false.
    end subroutine hungry_state_t_no_hungry

end module state_module
</code></pre>
<pre><code class="language-fortran">program state_main

    use state_module, only: person_t
    implicit none

    type(person_t) :: person
    call person%hungry_state%no_hungry
    call person%work
    call person%work
    call person%eat
    call person%eat

end program state_main

!&gt; Results shall be:

!  Ok, let us do work..
!  I am hungry, no work!!
!  Eatting..
!  Already baole!!

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç­–ç•¥æ¨¡å¼"><a class="header" href="#ç­–ç•¥æ¨¡å¼">ç­–ç•¥æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/strategy</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/strategy/go/example</p>
<p>ç­–ç•¥æ¨¡å¼èƒ½å°†è°ƒç”¨ç­–ç•¥åˆ¤æ–­çš„è¿‡ç¨‹æŠ½è±¡å‡ºæ¥ï¼Œå¹¶æå‰éƒ¨ç½²ç­–ç•¥ã€‚</p>
<pre><code class="language-fortran">module strategy_module

    implicit none
    private

    public :: add_t, sub_t, calculator_t

    type, abstract :: strategy_t
    contains
        procedure(strategy_t_calc), deferred :: calc
    end type strategy_t

    abstract interface
        integer function strategy_t_calc(self, a, b) result(c)
            import strategy_t
            class(strategy_t), intent(inout) :: self
            integer, intent(in) :: a, b
        end function strategy_t_calc
    end interface

    type, extends(strategy_t) :: add_t
    contains
        procedure :: calc =&gt; add_t_calc
    end type add_t

    type, extends(strategy_t) :: sub_t
    contains
        procedure :: calc =&gt; sub_t_calc
    end type sub_t

    type calculator_t
        class(strategy_t), pointer :: strategy
    contains
        procedure :: set_strategy =&gt; calculator_t_set_strategy
        procedure :: get_result =&gt; calculator_t_get_result
    end type calculator_t

contains

    integer function add_t_calc(self, a, b) result(c)
        class(add_t), intent(inout) :: self
        integer, intent(in) :: a, b
        c = a + b
    end function add_t_calc

    integer function sub_t_calc(self, a, b) result(c)
        class(sub_t), intent(inout) :: self
        integer, intent(in) :: a, b
        c = a - b
    end function sub_t_calc

    subroutine calculator_t_set_strategy(self, strategy)
        class(calculator_t), intent(inout) :: self
        class(strategy_t), intent(in), target :: strategy
        self%strategy =&gt; strategy
    end subroutine calculator_t_set_strategy

    integer function calculator_t_get_result(self, a, b) result(c)
        class(calculator_t), intent(inout) :: self
        integer, intent(in) :: a, b
        c = self%strategy%calc(a, b)
    end function calculator_t_get_result

end module strategy_module
</code></pre>
<pre><code class="language-fortran">program strategy_main

    use strategy_module, only: add_t, sub_t, calculator_t
    implicit none
    type(add_t) :: add
    type(sub_t) :: sub
    type(calculator_t) :: calculator

    call calculator%set_strategy(add)
    print *, &quot;Add:&quot;, calculator%strategy%calc(1, 1)

    call calculator%set_strategy(sub)
    print *, &quot;Sub:&quot;, calculator%strategy%calc(1, 1)

end program strategy_main

!&gt; Results shall be:

!  Add:           2
!  Sub:           0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¨¡æ¿æ–¹æ³•æ¨¡å¼"><a class="header" href="#æ¨¡æ¿æ–¹æ³•æ¨¡å¼">æ¨¡æ¿æ–¹æ³•æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/template-method</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/template-method/go/example</p>
<pre><code class="language-fortran">module template_method_module

    implicit none
    private

    public :: otp_t, sms_t, email_t

    type, abstract :: iopt_t
    contains
        procedure(iopt_t_gen_random_opt), deferred :: gen_random_opt
        procedure(iopt_t_save_opt_cache), deferred :: save_opt_cache
        procedure(iopt_t_get_message), deferred :: get_message
        procedure(iopt_t_send_notification), deferred :: send_notification
        procedure(iopt_t_publish_metric), deferred :: publish_metric
    end type iopt_t

    abstract interface

        function iopt_t_gen_random_opt(self, len) result(random_opt)
            import iopt_t
            class(iopt_t), intent(inout) :: self
            integer, intent(in) :: len
            character(:), allocatable :: random_opt
        end function iopt_t_gen_random_opt

        subroutine iopt_t_save_opt_cache(self, otp)
            import iopt_t
            class(iopt_t), intent(inout) :: self
            character(*), intent(inout) :: otp
        end subroutine iopt_t_save_opt_cache

        function iopt_t_get_message(self, otp) result(msg)
            import iopt_t
            class(iopt_t), intent(inout) :: self
            character(*), intent(inout) :: otp
            character(:), allocatable :: msg
        end function iopt_t_get_message

        subroutine iopt_t_send_notification(self, msg)
            import iopt_t
            class(iopt_t), intent(inout) :: self
            character(*), intent(inout) :: msg
        end subroutine iopt_t_send_notification

        subroutine iopt_t_publish_metric(self)
            import iopt_t
            class(iopt_t), intent(inout) :: self
        end subroutine iopt_t_publish_metric

    end interface

    ! - - - - - - - - - - - - -

    type otp_t
        class(iopt_t), pointer :: iopt
    contains
        procedure :: gen_and_send_otp =&gt; otp_t_gen_and_send_otp
    end type otp_t

    type, extends(iopt_t) :: sms_t
    contains
        procedure :: gen_random_opt =&gt; sms_t_gen_random_opt
        procedure :: save_opt_cache =&gt; sms_t_save_opt_cache
        procedure :: get_message =&gt; sms_t_get_message
        procedure :: send_notification =&gt; sms_t_send_notification
        procedure :: publish_metric =&gt; sms_t_publish_metric
    end type sms_t

    type, extends(iopt_t) :: email_t
    contains
        procedure :: gen_random_opt =&gt; email_t_gen_random_opt
        procedure :: save_opt_cache =&gt; email_t_save_opt_cache
        procedure :: get_message =&gt; email_t_get_message
        procedure :: send_notification =&gt; email_t_send_notification
        procedure :: publish_metric =&gt; email_t_publish_metric
    end type email_t

contains

    subroutine otp_t_gen_and_send_otp(self, otp_length)
        class(otp_t), intent(inout) :: self
        integer, intent(in) :: otp_length

        character(:), allocatable :: otp
        character(:), allocatable :: msg

        otp = self%iopt%gen_random_opt(otp_length)
        call self%iopt%save_opt_cache(otp)
        msg = self%iopt%get_message(otp)
        call self%iopt%send_notification(msg)
        call self%iopt%publish_metric()

    end subroutine otp_t_gen_and_send_otp

    ! - - - - - - - - - -

    function sms_t_gen_random_opt(self, len) result(random_opt)
        class(sms_t), intent(inout) :: self
        integer, intent(in) :: len
        character(:), allocatable :: random_opt

        random_opt = &quot;1234&quot;
        print *, &quot;SMS: generating random otp &quot;, random_opt

    end function sms_t_gen_random_opt

    subroutine sms_t_save_opt_cache(self, otp)
        class(sms_t), intent(inout) :: self
        character(*), intent(inout) :: otp

        print *, &quot;SMS: saving otp: &quot;, otp, &quot; to cache&quot;

    end subroutine sms_t_save_opt_cache

    function sms_t_get_message(self, otp) result(msg)
        class(sms_t), intent(inout) :: self
        character(*), intent(inout) :: otp
        character(:), allocatable :: msg

        msg = &quot;SMS OTP for login is &quot;//otp

    end function sms_t_get_message

    subroutine sms_t_send_notification(self, msg)
        class(sms_t), intent(inout) :: self
        character(*), intent(inout) :: msg

        print *, &quot;SMS: sending sms: &quot;//msg

    end subroutine sms_t_send_notification

    subroutine sms_t_publish_metric(self)
        class(sms_t), intent(inout) :: self

        print *, &quot;SMS: publishing metric&quot;

    end subroutine sms_t_publish_metric

    ! - - - - - - - - - -

    function email_t_gen_random_opt(self, len) result(random_opt)
        class(email_t), intent(inout) :: self
        integer, intent(in) :: len
        character(:), allocatable :: random_opt

        random_opt = &quot;1234&quot;
        print *, &quot;EMAIL: generating random otp &quot;, random_opt

    end function email_t_gen_random_opt

    subroutine email_t_save_opt_cache(self, otp)
        class(email_t), intent(inout) :: self
        character(*), intent(inout) :: otp

        print *, &quot;EMAIL: saving otp: &quot;, otp, &quot; to cache&quot;

    end subroutine email_t_save_opt_cache

    function email_t_get_message(self, otp) result(msg)
        class(email_t), intent(inout) :: self
        character(*), intent(inout) :: otp
        character(:), allocatable :: msg

        msg = &quot;EMAIL OTP for login is &quot;//otp

    end function email_t_get_message

    subroutine email_t_send_notification(self, msg)
        class(email_t), intent(inout) :: self
        character(*), intent(inout) :: msg

        print *, &quot;EMAIL: sending email: &quot;//msg

    end subroutine email_t_send_notification

    subroutine email_t_publish_metric(self)
        class(email_t), intent(inout) :: self

        print *, &quot;EMAIL: publishing metric&quot;

    end subroutine email_t_publish_metric

end module template_method_module
</code></pre>
<pre><code class="language-fortran">program template_method_main

    use template_method_module, only: otp_t, sms_t, email_t

    type(otp_t) :: otp
    type(sms_t), target :: sms_otp
    type(email_t), target :: email_otp

    sms_otp = sms_t()
    otp%iopt =&gt; sms_otp
    call otp%gen_and_send_otp(4)

    write (*, *)

    email_otp = email_t()
    otp%iopt =&gt; email_otp
    call otp%gen_and_send_otp(4)

end program template_method_main

!&gt; Results shall be:

!  SMS: generating random otp 1234
!  SMS: saving otp: 1234 to cache
!  SMS: sending sms: SMS OTP for login is 1234
!  SMS: publishing metric
!
!  EMAIL: generating random otp 1234
!  EMAIL: saving otp: 1234 to cache
!  EMAIL: sending email: EMAIL OTP for login is 1234
!  EMAIL: publishing metric
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è®¿é—®è€…æ¨¡å¼"><a class="header" href="#è®¿é—®è€…æ¨¡å¼">è®¿é—®è€…æ¨¡å¼</a></h1>
<p>æ­£æ–‡ï¼šhttps://refactoringguru.cn/design-patterns/visitor</p>
<p>Goä»£ç ï¼šhttps://refactoringguru.cn/design-patterns/visitor/go/example</p>
<pre><code class="language-fortran">!&gt; Reference: https://refactoring.guru/design-patterns/visitor/go/example
module visitor_pattern

    implicit none
    private

    public :: square, circle, rectangle, area_calculator, middle_coordinates

    !&gt; Two abstract classes

    type, abstract :: shape
    contains
        procedure(get_type_procedure), deferred :: get_type
        procedure(accept_procedure), deferred :: accept
    end type shape

    type, abstract :: visitor
    contains
        procedure(visit_procedure), deferred :: visit
    end type visitor

    abstract interface
        function get_type_procedure(self) result(result)
            import shape
            class(shape), intent(inout) :: self
            character(:), allocatable :: result
        end function get_type_procedure
        subroutine accept_procedure(self, v)
            import shape, visitor
            class(shape), intent(inout) :: self
            class(visitor), intent(inout) :: v
        end subroutine accept_procedure
        subroutine visit_procedure(self, s)
            import visitor, shape
            class(visitor), intent(inout) :: self
            class(shape), intent(inout) :: s
        end subroutine visit_procedure
    end interface

    !&gt; Specific shapes

    type, extends(shape) :: square
        integer :: side
    contains
        procedure :: get_type =&gt; square_get_type
        procedure :: accept =&gt; square_accept
    end type square

    type, extends(shape) :: circle
        integer :: radius
    contains
        procedure :: get_type =&gt; circle_get_type
        procedure :: accept =&gt; circle_accept
    end type circle

    type, extends(shape) :: rectangle
        integer :: l
        integer :: b
    contains
        procedure :: get_type =&gt; rectangle_get_type
        procedure :: accept =&gt; rectangle_accept
    end type rectangle

    !&gt; Specific visitors

    type, extends(visitor) :: area_calculator
        integer :: area
    contains
        procedure :: visit =&gt; area_calculator_visit
    end type area_calculator

    type, extends(visitor) :: middle_coordinates
        integer :: x, y
    contains
        procedure :: visit =&gt; middle_coordinates_visit
    end type middle_coordinates

contains

    function square_get_type(self) result(result)
        class(square), intent(inout) :: self
        character(:), allocatable :: result
        result = &quot;Square&quot;
    end function square_get_type

    function circle_get_type(self) result(result)
        class(circle), intent(inout) :: self
        character(:), allocatable :: result
        result = &quot;Circle&quot;
    end function circle_get_type

    function rectangle_get_type(self) result(result)
        class(rectangle), intent(inout) :: self
        character(:), allocatable :: result
        result = &quot;Rectangle&quot;
    end function rectangle_get_type

    subroutine square_accept(self, v)
        class(square), intent(inout) :: self
        class(visitor), intent(inout) :: v
        call v%visit(self)
    end subroutine square_accept

    subroutine circle_accept(self, v)
        class(circle), intent(inout) :: self
        class(visitor), intent(inout) :: v
        call v%visit(self)
    end subroutine circle_accept

    subroutine rectangle_accept(self, v)
        class(rectangle), intent(inout) :: self
        class(visitor), intent(inout) :: v
        call v%visit(self)
    end subroutine rectangle_accept

    subroutine area_calculator_visit(self, s)
        class(area_calculator), intent(inout) :: self
        class(shape), intent(inout) :: s
        select type (s)
        type is (square)
            print *, &quot;Calculating area for square.ğŸ”¥&quot;
        type is (circle)
            print *, &quot;Calculating area for circle.ğŸ”¥&quot;
        type is (rectangle)
            print *, &quot;Calculating area for rectangle.ğŸ”¥&quot;
        end select
    end subroutine area_calculator_visit

    subroutine middle_coordinates_visit(self, s)
        class(middle_coordinates), intent(inout) :: self
        class(shape), intent(inout) :: s
        select type (s)
        type is (square)
            print *, &quot;Calculating middle point coordinates for square.ğŸ’ &quot;
        type is (circle)
            print *, &quot;Calculating middle point coordinates for circle.ğŸ’ &quot;
        type is (rectangle)
            print *, &quot;Calculating middle point coordinates for rectangle.ğŸ’ &quot;
        end select
    end subroutine middle_coordinates_visit

end module visitor_pattern
</code></pre>
<pre><code class="language-fortran">!&gt; Reference: https://refactoring.guru/design-patterns/visitor/go/example
program test_visitor

    use visitor_pattern, only: square, circle, rectangle, area_calculator, middle_coordinates

    type(square) :: s = square(side=2)
    type(circle) :: c = circle(radius=3)
    type(rectangle) :: r = rectangle(l=2, b=3)

    type(area_calculator) :: a
    type(middle_coordinates) :: m

    !&gt; area_calculator visiting shapes
    call s%accept(a)
    call c%accept(a)
    call r%accept(a)

    !&gt; middle_coordinates visiting shapes
    call s%accept(m)
    call c%accept(m)
    call r%accept(m)

    !&gt; Getting type of shape
    print *, s%get_type()
    print *, c%get_type()
    print *, r%get_type()

end program test_visitor

!&gt; Results shall be:

!  Calculating area for square.ğŸ”¥
!  Calculating area for circle.ğŸ”¥
!  Calculating area for rectangle.ğŸ”¥
!  Calculating middle point coordinates for square.ğŸ’ 
!  Calculating middle point coordinates for circle.ğŸ’ 
!  Calculating middle point coordinates for rectangle.ğŸ’ 
!  Square
!  Circle
!  Rectangle
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¨¡å‹ä¸ç®—æ³•"><a class="header" href="#æ¨¡å‹ä¸ç®—æ³•">æ¨¡å‹ä¸ç®—æ³•</a></h1>
<p>è¿™ç¯‡ç•ªå¤–ï¼Œæ¥è‡ªå®¤å‹çš„ä¸€ä¸ªé—®é¢˜ï¼Œä»–åœ¨ä¸æ•°å­¦å­¦é™¢çš„åŒå­¦åˆä½œæ—¶ï¼Œä»–è®¤ä¸ºæ¨¡å‹ä¸ç®—æ³•å·®ä¸å¤šæ˜¯ä¸€ä¸ªä¸œè¥¿ï¼Œä½†æ•°å­¦å­¦é™¢çš„åŒå­¦ä¸è®¤åŒã€‚</p>
<p>åœ¨ç¼–ç¨‹çš„ä¸–ç•Œé‡Œï¼Œä¸»è¦ç”±å‡½æ•°ã€æ•°æ®ç»„æˆã€‚æˆ‘ä»¬é€šå¸¸å°†å‡½æ•°ç§°ä¸ºæ–¹æ³•ï¼Œé¢å‘å¯¹è±¡æ€æƒ³ä¸­ï¼Œä¸€ä¸ªå¯¹è±¡ç”±è‹¥å¹²ä¸ªæ•°æ®å’Œæ–¹æ³•ç»„æˆã€‚</p>
<p>å½“æˆ‘ä»¬è¦å»ºæ¨¡æ—¶ï¼Œé¢å‘å¯¹è±¡å¾€å¾€æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ€è·¯ï¼Œæ‰€ä»¥ï¼Œæ¨¡å‹æ˜¯å•ä¸ªæˆ–è€…å¤šä¸ªå¯¹è±¡ç»„æˆçš„ä¸€ä¸ªæ•°æ®å®ä½“ï¼Œå…¶æ ¸å¿ƒæ˜¯æ¨¡å‹å†…éƒ¨å¯¹è±¡é—´çš„ä¿¡æ¯ä¼ é€’ï¼Œå½¢æˆç›¸åº”çš„æ¨¡å‹æ€»ä½“åŠŸèƒ½ã€‚</p>
<p>è¿™æ ·ç†è§£çš„è¯ï¼Œç®—æ³•åˆ™æ›´å¤šæ˜¯æ–¹æ³•ï¼ˆå‡½æ•°ï¼‰è€Œéå¯¹è±¡çš„é›†åˆï¼Œç®—æ³•å¯ä»¥æ˜¯å•ä¸ªæˆ–è€…å¤šä¸ªå‡½æ•°çš„æ–¹æ³•å®ä½“ã€‚ä½†è¿™ä¹Ÿä¸å°½ç„¶ï¼Œç®—æ³•ä¸­å¯ä»¥è¾…åŠ©é¢å‘å¯¹è±¡çš„å»ºæ¨¡ç‰¹æ€§ï¼Œä½†ç®—æ³•æ›´æ³¨é‡å½¢æˆçš„æ–¹æ³•æ€»ä½“åŠŸèƒ½ï¼Œå½¢æˆAPIï¼Œè¢«è°ƒç”¨ã€‚</p>
<p>æ­¤å¤–ï¼Œè¿˜æœ‰æ¨¡å¼ï¼ˆæˆ–è€…è®¾è®¡æ¨¡å¼ï¼‰ï¼Œå³æœ¬ä¹¦çš„é‡ç‚¹ï¼Œå®ƒæ˜¯å¯¹ç‰¹ç‚¹åœºæ™¯ã€æ¨¡å‹ã€ç®—æ³•ç­‰å®ä½“ï¼Œäº‹å…ˆè¢«è®°å½•ä¸‹æ¥ï¼Œæ–¹ä¾¿åäººæŒ‰å›¾ç´¢éª¥ï¼Œæ˜¯æ¯å‹å›¾çº¸ï¼Œä¾›ä½ è§†å®é™…æƒ…å†µè€Œå®šã€‚</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
